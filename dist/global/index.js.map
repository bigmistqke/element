{"version":3,"file":"index.js","mappings":"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","sources":["webpack://LUME/../variable/node_modules/lowclass/src/native.ts","webpack://LUME/../variable/node_modules/lowclass/src/utils.ts","webpack://LUME/webpack/bootstrap","webpack://LUME/webpack/runtime/define property getters","webpack://LUME/webpack/runtime/hasOwnProperty shorthand","webpack://LUME/webpack/runtime/make namespace object","webpack://LUME/../../node_modules/solid-js/dist/solid.js","webpack://LUME/../../node_modules/solid-js/web/dist/web.js","webpack://LUME/./src/_utils.ts","webpack://LUME/./src/LumeElement.ts","webpack://LUME/../variable/node_modules/lowclass/src/Class.ts","webpack://LUME/../variable/node_modules/lowclass/src/multiple.ts","webpack://LUME/../variable/src/index.ts","webpack://LUME/./src/attribute.ts","webpack://LUME/./src/element.ts","webpack://LUME/./src/css.ts","webpack://LUME/./src/index.ts"],"sourcesContent":["// borrowed from (and slightly modified) https://github.com/Mr0grog/newless\n// The newless license is BSD 3:\n\n// TODO no any types\n\n/*\n * Copyright (c) 2013-2016, Rob Brackett\n * Copyright (c) 2018, Joseph Orbegoso Pea\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport {getFunctionBody, setDescriptor, Constructor} from './utils.js'\n\nexport {newless as native}\n\nexport default newless\n\nvar supportsSpread = isSyntaxSupported('Object(...[{}])')\nvar supportsClass = isSyntaxSupported('class Test {}')\nvar supportsNewTarget = isSyntaxSupported('new.target')\n\n// Used to track the original wrapped constructor on a newless instance\nvar TRUE_CONSTRUCTOR = Symbol ? Symbol('trueConstructor') : '__newlessTrueConstructor__'\n\nvar setPrototype =\n\tObject.setPrototypeOf ||\n\tfunction setPrototypeOf(object, newPrototype) {\n\t\tobject.__proto__ = newPrototype\n\t}\n\n// Polyfill for Reflect.construct\nvar construct =\n\t(Reflect && Reflect.construct) ||\n\t(function () {\n\t\tif (supportsClass) {\n\t\t\treturn Function(\n\t\t\t\t'constructor, args, target',\n\t\t\t\t`\n                'use strict';\n\n                if (arguments.length === 3 && typeof target !== 'function')\n                    throw new TypeError(target + ' is not a constructor');\n\n                target = target || constructor;\n\n                // extend target so the right prototype is constructed (or nearly the\n                // right one; ideally we'd do instantiator.prototype = target.prototype,\n                // but a class's prototype property is not writable)\n                class instantiator extends target {};\n                // but ensure the *logic* is 'constructor' for ES2015-compliant engines\n                Object.setPrototypeOf(instantiator, constructor);\n                // ...and for Safari 9\n                instantiator.prototype.constructor = constructor;\n\n                // The spread operator is *dramatically faster, so use it if we can:\n                // http://jsperf.com/new-via-spread-vs-dynamic-function/4\n                ${\n\t\t\t\t\tsupportsSpread\n\t\t\t\t\t\t? `\n\n                    var value = new instantiator(...([].slice.call(args)));\n\n                `\n\t\t\t\t\t\t: `\n\n                    // otherwise, create a dynamic function in order to use 'new'\n                    // Note using 'function.bind' would be simpler, but is much slower:\n                    // http://jsperf.com/new-operator-with-dynamic-function-vs-bind\n                    var argList = '';\n                    for (var i = 0, len = args.length; i < len; i++) {\n                    if (i > 0) argList += ',';\n                    argList += 'args[' + i + ']';\n                    }\n                    var constructCall = Function('constructor, args',\n                    'return new constructor( ' + argList + ' );'\n                    );\n                    var value = constructCall(constructor, args);\n\n                    args = Array.prototype.slice.call(args);\n                    args = [null].concat(args);\n                    var value = new constructor.bind.apply(constructor, args);\n\n                `\n\t\t\t\t}\n\n                // fix up the prototype so it matches the intended one, not one who's\n                // prototype is the intended one :P\n                Object.setPrototypeOf(value, target.prototype);\n                return value;\n            `,\n\t\t\t)\n\n\t\t\t//return Function(\"constructor, args, newTarget\", `\n\t\t\t//  'use strict';\n\n\t\t\t//  if (arguments.length === 3 && typeof newTarget === undefined)\n\t\t\t//    throw new TypeError('undefined is not a constructor');\n\n\t\t\t//  newTarget = newTarget || constructor;\n\n\t\t\t//  ${ supportsSpread ? `\n\n\t\t\t//    var value = new constructor(...([].slice.call(args)));\n\n\t\t\t//  `:`\n\n\t\t\t//    args = Array.prototype.slice.call(args);\n\t\t\t//    args = [null].concat(args);\n\t\t\t//    var value = new constructor.bind.apply(constructor, args);\n\n\t\t\t//  `}\n\n\t\t\t//  Object.setPrototypeOf(value, newTarget.prototype);\n\t\t\t//  return value;\n\t\t\t//`);\n\t\t} else {\n\t\t\tvar instantiator = function () {} as any\n\t\t\treturn function construct(constructor: any, args: any, target: any) {\n\t\t\t\tif (arguments.length === 3 && typeof target !== 'function')\n\t\t\t\t\tthrow new TypeError(target + ' is not a constructor')\n\t\t\t\tinstantiator.prototype = (target || constructor).prototype\n\t\t\t\tvar instance = new instantiator()\n\t\t\t\tvar value = constructor.apply(instance, args)\n\t\t\t\tif (typeof value === 'object' && value) {\n\t\t\t\t\t// we can do better if __proto__ is available (in some ES5 environments)\n\t\t\t\t\tvalue.__proto__ = (target || constructor).prototype\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn instance\n\t\t\t}\n\t\t}\n\t})()\n\n// ES2015 class methods are non-enumerable; we need a helper for copying them.\nvar SKIP_PROPERTIES: (string | symbol)[] = ['arguments', 'caller', 'length', 'name', 'prototype']\nfunction copyProperties(source: any, destination: any) {\n\tif (Object.getOwnPropertyNames && Object.defineProperty) {\n\t\tvar properties: (string | symbol)[] = Object.getOwnPropertyNames(source)\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tproperties = properties.concat(Object.getOwnPropertySymbols(source))\n\t\t}\n\t\tfor (var i = properties.length - 1; i >= 0; i--) {\n\t\t\tif (SKIP_PROPERTIES.indexOf(properties[i]) === -1) {\n\t\t\t\tObject.defineProperty(\n\t\t\t\t\tdestination,\n\t\t\t\t\tproperties[i],\n\t\t\t\t\tObject.getOwnPropertyDescriptor(source, properties[i])!,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var property in source) {\n\t\t\tdestination[property] = source[property]\n\t\t}\n\t}\n}\n\ntype FuncLikeCtor<T, S = {}> = {\n\t(): T\n\tnew (): T\n} & S\n\nfunction newless<T extends Constructor>(constructor: T): FuncLikeCtor<InstanceType<T>, T> {\n\tvar name = constructor.name\n\n\t// V8 and newer versions of JSCore return the full class declaration from\n\t// `toString()`, which lets us be a little smarter and more performant\n\t// about what to do, since we know we are dealing with a \"class\". Note,\n\t// however, not all engines do this. This could be false and the constructor\n\t// might still use class syntax.\n\tvar usesClassSyntax = constructor.toString().substr(0, 5) === 'class'\n\n\tvar requiresNew = usesClassSyntax ? true : null\n\n\tvar newlessConstructor = (() =>\n\t\tfunction (this: any) {\n\t\t\t// If called with an already valid 'this', preserve that 'this' value\n\t\t\t// in the super-type's constructor whenever possible. With function\n\t\t\t// constructors (as opposed to class constructors), it's possible to\n\t\t\t// alter the instance before calling the super constructor--so it's\n\t\t\t// important to preserve that instance if at all possible.\n\t\t\tif (!requiresNew && this instanceof newlessConstructor) {\n\t\t\t\t// requiresNew = 'false' indicates we know the 'new' operator isn't\n\t\t\t\t// necessary for this constructor, but 'null' indicates uncertainty,\n\t\t\t\t// so the call needs to handle potential errors the first time in\n\t\t\t\t// order to determine whether 'new' is definitely required.\n\t\t\t\tif (requiresNew === false) {\n\t\t\t\t\tconst returnValue = constructor.apply(this, arguments as any)\n\t\t\t\t\treturn (typeof returnValue === 'object' && returnValue) || this\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\trequiresNew = false\n\t\t\t\t\tconst returnValue = constructor.apply(this, arguments as any)\n\t\t\t\t\treturn (typeof returnValue === 'object' && returnValue) || this\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Do our best to only capture errors triggred by class syntax.\n\t\t\t\t\t// Unfortunately, there's no special error type for this and the\n\t\t\t\t\t// message is non-standard, so this is the best check we can do.\n\t\t\t\t\tif (\n\t\t\t\t\t\terror instanceof TypeError &&\n\t\t\t\t\t\t(/class constructor/i.test(error.message) || /use the 'new' operator/i.test(error.message)) // Custom Elements in Chrome\n\t\t\t\t\t\t// TODO: there might be other error messages we need to catch,\n\t\t\t\t\t\t// depending on engine and use case. We need to test in all browsers\n\t\t\t\t\t) {\n\t\t\t\t\t\t// mark this constructor as requiring 'new' for next time\n\t\t\t\t\t\trequiresNew = true\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terror instanceof Error &&\n\t\t\t\t\t\t\t/Illegal constructor/i.test(error.message) &&\n\t\t\t\t\t\t\tObject.create(constructor.prototype) instanceof Node\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t`The following error can happen if a Custom Element is called\nwith 'new' before being defined. The constructor was ${constructor.name}: `,\n\t\t\t\t\t\t\t\tconstructor,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// make a reasonably good replacement for 'new.target' which is a\n\t\t\t// syntax error in older engines\n\t\t\tvar newTarget\n\t\t\tvar hasNewTarget = false\n\t\t\tif (supportsNewTarget) {\n\t\t\t\teval('newTarget = new.target')\n\t\t\t\tif (newTarget) hasNewTarget = true\n\t\t\t}\n\t\t\tif (!supportsNewTarget || !hasNewTarget) {\n\t\t\t\tnewTarget = this instanceof newlessConstructor ? this.constructor : constructor\n\t\t\t}\n\t\t\tconst returnValue = construct(constructor, arguments, newTarget)\n\t\t\t// best effort to make things easy for functions inheriting from classes\n\t\t\tif (this instanceof newlessConstructor) {\n\t\t\t\tsetPrototype(this, returnValue)\n\t\t\t}\n\t\t\treturn returnValue\n\t\t})()\n\n\tif (name) {\n\t\tconst code = getFunctionBody(newlessConstructor)\n\n\t\tnewlessConstructor = Function(\n\t\t\t'constructor, construct, setPrototype, requiresNew, supportsNewTarget',\n\t\t\t`\n      var newlessConstructor = function ${name}() { ${code} };\n      return newlessConstructor\n    `,\n\t\t)(constructor, construct, setPrototype, requiresNew, supportsNewTarget)\n\t}\n\n\t// copy the `.length` value to the newless constructor\n\tif (constructor.length) {\n\t\t// length is not writable, only configurable, therefore the value\n\t\t// has to be set with a descriptor update\n\t\tsetDescriptor(newlessConstructor, 'length', {\n\t\t\tvalue: constructor.length,\n\t\t})\n\t}\n\n\tnewlessConstructor.prototype = Object.create(constructor.prototype)\n\tnewlessConstructor.prototype.constructor = newlessConstructor\n\n\t// NOTE: *usually* the below will already be true, but we ensure it here.\n\t// Safari 9 requires this for the 'super' keyword to work. Newer versions\n\t// of WebKit and other engines do not. Instead, they use the constructor's\n\t// prototype chain (which is correct by ES2015 spec) (see below).\n\tconstructor.prototype.constructor = constructor\n\n\t// for ES2015 classes, we need to make sure the constructor's prototype\n\t// is the super class's constructor. Further, optimize performance by\n\t// pointing at the actual constructor implementation instead of the\n\t// newless wrapper (in the case that it is wrapped by newless).\n\t;(newlessConstructor as any)[TRUE_CONSTRUCTOR] = constructor\n\n\tcopyProperties(constructor, newlessConstructor)\n\tsetPrototype(newlessConstructor, constructor)\n\n\treturn newlessConstructor as FuncLikeCtor<InstanceType<T>, T>\n}\n\n// Test whether a given syntax is supported\nfunction isSyntaxSupported(example: string, useStrict = true): boolean {\n\ttry {\n\t\treturn !!Function('', (useStrict ? \"'use strict';\" : '') + example)\n\t} catch (error) {\n\t\treturn false\n\t}\n}\n","// TODO no any\n\nexport class WeakTwoWayMap {\n\tm = new WeakMap()\n\tset(a: Object, b: Object) {\n\t\tthis.m.set(a, b)\n\t\tthis.m.set(b, a)\n\t}\n\tget(item: Object) {\n\t\treturn this.m.get(item)\n\t}\n\thas(item: Object) {\n\t\treturn this.m.has(item)\n\t}\n}\n\n// assumes the function opening, body, and closing are on separate lines\nexport function getFunctionBody(fn: Function): string {\n\tconst code = fn.toString().split('\\n')\n\tcode.shift() // remove opening line (function() {)\n\tcode.pop() // remove closing line (})\n\treturn code.join('\\n')\n}\n\nconst descriptorDefaults = {\n\tenumerable: true,\n\tconfigurable: true,\n}\n\n// makes it easier and less verbose to work with descriptors\nexport function setDescriptor(obj: Object, key: string, newDescriptor: PropertyDescriptor, inherited = false): void {\n\tlet currentDescriptor = inherited ? getInheritedDescriptor(obj, key) : Object.getOwnPropertyDescriptor(obj, key)\n\n\tnewDescriptor = overrideDescriptor(currentDescriptor, newDescriptor)\n\tObject.defineProperty(obj, key, newDescriptor)\n}\n\nexport function setDescriptors(obj: Object, newDescriptors: Record<string, PropertyDescriptor>): void {\n\tlet newDescriptor\n\tlet currentDescriptor\n\tconst currentDescriptors = Object.getOwnPropertyDescriptors(obj)\n\n\tfor (const key in newDescriptors) {\n\t\tnewDescriptor = newDescriptors[key]\n\t\tcurrentDescriptor = currentDescriptors[key]\n\t\tnewDescriptors[key] = overrideDescriptor(currentDescriptor, newDescriptor)\n\t}\n\n\tObject.defineProperties(obj, newDescriptors)\n}\n\nfunction overrideDescriptor(\n\toldDescriptor: PropertyDescriptor | undefined,\n\tnewDescriptor: PropertyDescriptor,\n): PropertyDescriptor {\n\tif (\n\t\t('get' in newDescriptor || 'set' in newDescriptor) &&\n\t\t('value' in newDescriptor || 'writable' in newDescriptor)\n\t) {\n\t\tthrow new TypeError('cannot specify both accessors and a value or writable attribute')\n\t}\n\n\tif (oldDescriptor) {\n\t\tif ('get' in newDescriptor || 'set' in newDescriptor) {\n\t\t\tdelete oldDescriptor.value\n\t\t\tdelete oldDescriptor.writable\n\t\t} else if ('value' in newDescriptor || 'writable' in newDescriptor) {\n\t\t\tdelete oldDescriptor.get\n\t\t\tdelete oldDescriptor.set\n\t\t}\n\t}\n\n\treturn {...descriptorDefaults, ...oldDescriptor, ...newDescriptor}\n}\n\n// TODO use signature override\nexport function propertyIsAccessor(obj: Object | PropertyDescriptor, key?: string, inherited = true): boolean {\n\tlet result = false\n\tlet descriptor: PropertyDescriptor | undefined\n\n\tif (arguments.length === 1) {\n\t\tdescriptor = obj\n\t} else {\n\t\tdescriptor = inherited ? getInheritedDescriptor(obj, key!) : Object.getOwnPropertyDescriptor(obj, key!)\n\t}\n\n\tif (descriptor && (descriptor.get || descriptor.set)) result = true\n\n\treturn result\n}\n\ninterface DescriptorWithOwner extends PropertyDescriptor {\n\towner: object\n}\n\nexport function getInheritedDescriptor(obj: object, key: string): DescriptorWithOwner | undefined {\n\tlet currentProto = obj\n\tlet descriptor\n\n\twhile (currentProto) {\n\t\tdescriptor = Object.getOwnPropertyDescriptor(currentProto, key)\n\n\t\tif (descriptor) {\n\t\t\t;(descriptor as DescriptorWithOwner).owner = currentProto\n\t\t\treturn descriptor as DescriptorWithOwner\n\t\t}\n\n\t\tcurrentProto = (currentProto as any).__proto__\n\t}\n\n\treturn void 0\n}\n\nexport function getInheritedPropertyNames(obj: Object): string[] {\n\tlet currentProto = obj\n\tlet keys: string[] = []\n\n\twhile (currentProto) {\n\t\tkeys = keys.concat(Object.getOwnPropertyNames(currentProto))\n\t\tcurrentProto = (currentProto as any).__proto__\n\t}\n\n\t// remove duplicates\n\tkeys = Array.from(new Set(keys))\n\n\treturn keys\n}\n\nexport type Constructor<T = object, A extends any[] = any[], Static = {}> = (new (...a: A) => T) & Static\n\n// this is used for type casting in special cases, see the declaration file\nexport function Constructor<T = object, Static = {}>(Ctor: Constructor<any>): Constructor<T> & Static {\n\treturn Ctor as unknown as Constructor<T> & Static\n}\n\n// check if an object has the given prototype in its chain\nexport function hasPrototype(obj: any, proto: any) {\n\tlet currentProto = obj.__proto__\n\n\tdo {\n\t\tif (proto === currentProto) return true\n\t\tcurrentProto = currentProto.__proto__\n\t} while (currentProto)\n\n\treturn false\n}\n\n// copy all properties (as descriptors) from source to destination\nexport function copyDescriptors(source: Object, destination: Object, mod?: any) {\n\tconst props = Object.getOwnPropertyNames(source)\n\tlet i = props.length\n\twhile (i--) {\n\t\tconst prop = props[i]\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(source, prop)\n\t\tif (mod) mod(descriptor)\n\t\tObject.defineProperty(destination, prop, descriptor!)\n\t}\n}\n\nexport function setDefaultPrototypeDescriptors(\n\tprototype: Object,\n\t{defaultClassDescriptor: {writable, enumerable, configurable}}: any,\n) {\n\tconst descriptors = Object.getOwnPropertyDescriptors(prototype)\n\tlet descriptor\n\n\tfor (const key in descriptors) {\n\t\tdescriptor = descriptors[key]\n\n\t\t// regular value\n\t\tif ('value' in descriptor || 'writable' in descriptor) {\n\t\t\tdescriptor.writable = writable\n\t\t}\n\n\t\t// accessor or regular value\n\t\tdescriptor.enumerable = enumerable\n\t\tdescriptor.configurable = configurable\n\t}\n\n\tsetDescriptors(prototype, descriptors)\n}\n\nexport function setDefaultStaticDescriptors(\n\tCtor: any,\n\t{defaultClassDescriptor: {writable, enumerable, configurable}}: any,\n\tstaticBlacklist?: (string | symbol)[],\n) {\n\tconst descriptors = Object.getOwnPropertyDescriptors(Ctor)\n\tlet descriptor\n\n\tfor (const key in descriptors) {\n\t\tif (staticBlacklist && staticBlacklist.includes(key)) {\n\t\t\tdelete descriptors[key]\n\t\t\tcontinue\n\t\t}\n\n\t\tdescriptor = descriptors[key]\n\n\t\t// regular value\n\t\tif ('value' in descriptor || 'writable' in descriptor) {\n\t\t\tdescriptor.writable = writable\n\t\t}\n\n\t\t// accessor or regular value\n\t\tdescriptor.enumerable = enumerable\n\t\tdescriptor.configurable = configurable\n\t}\n\n\tsetDescriptors(Ctor, descriptors)\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        unowned = fn.length === 0,\n        root = unowned && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  },\n        updateFn = unowned ? fn : () => fn(() => cleanNode(root));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  options || (options = {});\n  const contexts = new Set(),\n        [value, setValue] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      resolved = (\"initialValue\" in options),\n      dynamic = typeof source === \"function\" && createMemo(source);\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if (initP && (p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = null;\n      setError(err = e);\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      setValue(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = value();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        if (err) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) !== fn(key, p)) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    batch(fn);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n          if (o.pure) Updates.push(o);else Effects.push(o);\n          if (o.observers) markDownstream(o);\n        }\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookUpstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!Updates) Effects = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    const disposed = Transition.disposed;\n    res = Transition.resolve;\n    for (const e of Effects) {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    }\n    Transition = null;\n    batch(() => {\n      for (const d of disposed) cleanNode(d);\n      for (const v of sources) {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      }\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  for (const f of fns) f(err);\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = typeof observer === 'function' ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createComputed(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return (s = typeof s === \"function\" ? s() : s) == null ? {} : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nconst NoErrors = {};\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn(NoErrors));\n}\nfunction ErrorBoundary(props) {\n  let err = NoErrors;\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count) || NoErrors;\n  }\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n    if ((e = errored()) !== NoErrors) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(NoErrors))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let suspenseSetter, showContent, showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const [registry, setRegistry] = createSignal([]),\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        setRegistry(registry => [...registry, {\n          inFallback,\n          showContent,\n          showFallback\n        }]);\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reg = registry(),\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = reg.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      reg.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = reg.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = reg[n].inFallback();\n      if (!stop && !s) {\n        reg[n].showContent(visibleContent);\n        reg[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          reg[n].showFallback(visibleFallback);\n        } else reg[n].showFallback(false);\n        stop = true;\n        reg[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if ((error = err) || sharedConfig.done) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    } else if (p === null) sharedConfig.gather(key);\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","import { createMemo, createRoot, createRenderEffect, sharedConfig, enableHydration, createSignal, onCleanup, splitProps, untrack } from 'solid-js';\nexport { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, createRenderEffect as effect, getOwner, mergeProps } from 'solid-js';\n\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = /*#__PURE__*/new Set([\"className\", \"value\", \"readOnly\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = /*#__PURE__*/new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = {\n  className: \"class\",\n  htmlFor: \"for\"\n};\nconst PropAliases = {\n  class: \"className\",\n  formnovalidate: \"formNoValidate\",\n  ismap: \"isMap\",\n  nomodule: \"noModule\",\n  playsinline: \"playsInline\",\n  readonly: \"readOnly\"\n};\nconst DelegatedEvents = /*#__PURE__*/new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = /*#__PURE__*/new Set([\n\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\",\n\"set\", \"stop\",\n\"svg\", \"switch\", \"symbol\", \"text\", \"textPath\",\n\"tref\", \"tspan\", \"use\", \"view\", \"vkern\"]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = /*#__PURE__*/new Set([\"html\", \"base\", \"head\", \"link\", \"meta\", \"style\", \"title\", \"body\", \"address\", \"article\", \"aside\", \"footer\", \"header\", \"main\", \"nav\", \"section\", \"body\", \"blockquote\", \"dd\", \"div\", \"dl\", \"dt\", \"figcaption\", \"figure\", \"hr\", \"li\", \"ol\", \"p\", \"pre\", \"ul\", \"a\", \"abbr\", \"b\", \"bdi\", \"bdo\", \"br\", \"cite\", \"code\", \"data\", \"dfn\", \"em\", \"i\", \"kbd\", \"mark\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"small\", \"span\", \"strong\", \"sub\", \"sup\", \"time\", \"u\", \"var\", \"wbr\", \"area\", \"audio\", \"img\", \"map\", \"track\", \"video\", \"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"portal\", \"source\", \"svg\", \"math\", \"canvas\", \"noscript\", \"script\", \"del\", \"ins\", \"caption\", \"col\", \"colgroup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"button\", \"datalist\", \"fieldset\", \"form\", \"input\", \"label\", \"legend\", \"meter\", \"optgroup\", \"option\", \"output\", \"progress\", \"select\", \"textarea\", \"details\", \"dialog\", \"menu\", \"summary\", \"details\", \"slot\", \"template\", \"acronym\", \"applet\", \"basefont\", \"bgsound\", \"big\", \"blink\", \"center\", \"content\", \"dir\", \"font\", \"frame\", \"frameset\", \"hgroup\", \"image\", \"keygen\", \"marquee\", \"menuitem\", \"nobr\", \"noembed\", \"noframes\", \"plaintext\", \"rb\", \"rtc\", \"shadow\", \"spacer\", \"strike\", \"tt\", \"xmp\", \"a\", \"abbr\", \"acronym\", \"address\", \"applet\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"basefont\", \"bdi\", \"bdo\", \"bgsound\", \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\", \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"frame\", \"frameset\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"image\", \"img\", \"input\", \"ins\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"nav\", \"nobr\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"plaintext\", \"portal\", \"pre\", \"progress\", \"q\", \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"shadow\", \"slot\", \"small\", \"source\", \"spacer\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"xmp\", \"input\"]);\n\nfunction memo(fn, equals) {\n  return createMemo(fn, undefined, !equals ? {\n    equals\n  } : undefined);\n}\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n      aEnd = a.length,\n      bEnd = bLength,\n      aStart = 0,\n      bStart = 0,\n      after = a[aEnd - 1].nextSibling,\n      map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n              sequence = 1,\n              t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);\n  });\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, check, isSVG) {\n  const t = document.createElement(\"template\");\n  t.innerHTML = html;\n  let node = t.content.firstChild;\n  if (isSVG) node = node.firstChild;\n  return node;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);\n}\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, handler[0] = e => handlerFn.call(node, handler[1], e));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n        prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n          classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev = {}) {\n  const nodeStyle = node.style;\n  const prevString = typeof prev === \"string\";\n  if (value == null && prevString || typeof value === \"string\") return nodeStyle.cssText = value;\n  prevString && (nodeStyle.cssText = undefined, prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, accessor, isSVG, skipChildren) {\n  if (typeof accessor === \"function\") {\n    createRenderEffect(current => spreadExpression(node, accessor(), current, isSVG, skipChildren));\n  } else spreadExpression(node, accessor, undefined, isSVG, skipChildren);\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = globalThis._$HY.load;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes]);\n  sharedConfig.context = null;\n  return dispose;\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    return template.cloneNode(true);\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n      count = 0,\n      current = [];\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"#\") count++;else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const {\n        completed,\n        events\n      } = sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef) {\n  let isCE, isProp, isChildProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) {\n      value(node);\n    }\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e = prop.slice(3);\n    prev && node.removeEventListener(e, prev);\n    value && node.addEventListener(e, value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e = prop.slice(10);\n    prev && node.removeEventListener(e, prev, true);\n    value && node.addEventListener(e, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (PropAliases[prop] || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\"))) {\n    if (prop === \"class\" || prop === \"className\") className(node, value);else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;else node[PropAliases[prop] || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) {\n    sharedConfig.done = true;\n    document.querySelectorAll(\"[id^=pl-]\").forEach(elem => elem.remove());\n  }\n  while (node !== null) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n    node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;\n  }\n}\nfunction spreadExpression(node, props, prevProps = {}, isSVG, skipChildren) {\n  props || (props = {});\n  if (!skipChildren && \"children\" in props) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  props.ref && props.ref(node);\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context && !current) current = [...parent.childNodes];\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n        multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (sharedConfig.context) return current;\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context) {\n      for (let i = 0; i < array.length; i++) {\n        if (array[i].parentNode) return current = array;\n      }\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context && value.parentNode) return current = multi ? [value] : value;\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n        prev = current && current[i];\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if ((typeof item) === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], prev) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) {\n        normalized.push(prev);\n      } else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key)) sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction Assets() {\n  return;\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction resolveSSRNode(node) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrSpread(accessor) {}\nfunction ssrAttribute(key, value) {}\nfunction ssrHydrationKey() {}\nfunction escape(html) {}\nfunction generateHydrationScript() {}\n\nconst isServer = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props,\n        marker = document.createTextNode(\"\"),\n        mount = props.mount || document.body;\n  function renderPortal() {\n    if (sharedConfig.context) {\n      const [s, set] = createSignal(false);\n      queueMicrotask(() => set(true));\n      return () => s() && props.children;\n    } else return () => props.children;\n  }\n  if (mount instanceof HTMLHeadElement) {\n    const [clean, setClean] = createSignal(false);\n    const cleanup = () => setClean(true);\n    createRoot(dispose => insert(mount, () => !clean() ? renderPortal()() : dispose(), null));\n    onCleanup(() => {\n      if (sharedConfig.context) queueMicrotask(cleanup);else cleanup();\n    });\n  } else {\n    const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n      mode: \"open\"\n    }) : container;\n    Object.defineProperty(container, \"host\", {\n      get() {\n        return marker.parentNode;\n      }\n    });\n    insert(renderRoot, renderPortal());\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    onCleanup(() => mount.removeChild(container));\n  }\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  const cached = createMemo(() => p.component);\n  return createMemo(() => {\n    const component = cached();\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport { Aliases, Assets, ChildProperties, DOMElements, DelegatedEvents, Dynamic, Assets as HydrationScript, NoHydration, Portal, PropAliases, Properties, SVGElements, SVGNamespace, addEventListener, assign, classList, className, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, generateHydrationScript, getHydrationKey, getNextElement, getNextMarker, getNextMatch, hydrate, innerHTML, insert, isServer, memo, render, renderToStream, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrAttribute, ssrClassList, ssrHydrationKey, ssrSpread, ssrStyle, style, template };\n","/**\n * Execute the given `func`tion on the next micro \"tick\" of the JS engine.\n */\nexport function defer(func: () => unknown): Promise<unknown> {\n\t// \"defer\" is used as a semantic label for Promise.resolve().then\n\treturn Promise.resolve().then(func)\n}\n\n/**\n * This is an identity \"template string tag function\", which when applied to a\n * template string returns the equivalent of not having used a template tag on\n * a template string to begin with.\n *\n * For example, The following two strings are equivalent:\n *\n * ```js\n * const number = 42\n * const string1 = `meaning of life: ${number}`\n * const string2 = identityTemplateTag`meaning of life: ${number}`\n * ```\n *\n * This can be useful when assigning it to variables like `css` or `html` in\n * order to trigger syntax checking and highlighting inside template strings\n * without actually doing anything to the string (a no-op).\n */\nexport function identityTemplateTag(stringsParts: TemplateStringsArray, ...values: any[]): string {\n\t// unfortunately, it does incur some unnecessary runtime overhead in order to\n\t// receive the string parts and the interpolated values and concatenate them\n\t// all together into the same string as if we hadn't used a template tag.\n\n\tlet str = ''\n\n\tfor (let i = 0; i < values.length; i++) str += stringsParts[i] + String(values[i])\n\n\treturn str + stringsParts[stringsParts.length - 1]\n}\n\nexport function camelCaseToDash(str: string): string {\n\treturn str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase()\n}\n\nexport function defineProp(obj: any, prop: string, value: any) {\n\tObject.defineProperty(obj, prop, {\n\t\tvalue,\n\t\twritable: true,\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t})\n}\n\ndeclare const global: any\n\nexport function getGlobal(): Window {\n\tif (typeof globalThis !== 'undefined') return globalThis as any\n\telse if (typeof window !== 'undefined') return window\n\telse if (typeof global !== 'undefined') return global as any\n\telse return Function('return this')()\n}\n\n// TYPES\n\n// https://github.com/type-challenges/type-challenges/issues/9116\n// More solutions at https://github.com/type-challenges/type-challenges/tree/main/questions/00114-hard-camelcase\n//\n// bug, fooBar becomes foobar, https://github.com/type-challenges/type-challenges/issues/9116#issuecomment-1107928665\n// export type JoinToCamelCase<\n// \tS extends string,\n// \tSep extends string = '-',\n// \tR extends string = '',\n// > = S extends `${infer First}${Sep}${infer Rest}`\n// \t? R extends ''\n// \t\t? JoinToCamelCase<Lowercase<Rest>, Sep, `${R}${Lowercase<First>}`>\n// \t\t: JoinToCamelCase<Lowercase<Rest>, Sep, `${R}${Capitalize<First>}`>\n// \t: R extends ''\n// \t? Lowercase<S>\n// \t: `${R}${Capitalize<S>}`\n//\nexport type JoinToCamelCase<\n\tS extends string,\n\tSep extends string = '-',\n\tUPPER extends boolean = false,\n\tRes extends string = '',\n> = S extends `${infer L}${infer R}`\n\t? L extends Sep\n\t\t? JoinToCamelCase<R, Sep, true, Res>\n\t\t: UPPER extends true\n\t\t? JoinToCamelCase<R, Sep, false, `${Res}${Uppercase<L>}`>\n\t\t: JoinToCamelCase<R, Sep, false, `${Res}${Lowercase<L>}`>\n\t: Res\n\n// https://github.com/type-challenges/type-challenges/issues/9098\n// More solutions at https://github.com/type-challenges/type-challenges/blob/main/questions/00612-medium-kebabcase/README.md\n//\n// export type SplitCamelCase<\n// \tS extends string,\n// \tSep extends string = '-',\n// \tisFirstChar = true,\n// > = S extends `${infer s}${infer right}`\n// \t? s extends Lowercase<s>\n// \t\t? `${s}${SplitCamelCase<right, Sep, false>}`\n// \t\t: isFirstChar extends true\n// \t\t? `${Lowercase<s>}${SplitCamelCase<right, Sep, false>}`\n// \t\t: `${Sep}${Lowercase<s>}${SplitCamelCase<right, Sep, false>}`\n// \t: S\n//\n//\n//\n// type FirstLowcase<T extends string> = T extends `${infer F}${infer R}`\n// \t? F extends Lowercase<F>\n// \t\t? T\n// \t\t: `${Lowercase<F>}${R}`\n// \t: T\n// type SplitCamelCase<S extends string, Sep extends string = '-'> = S extends `${infer F}${infer R}`\n// \t? R extends FirstLowcase<R>\n// \t\t? `${FirstLowcase<F>}${SplitCamelCase<R, Sep>}`\n// \t\t: `${FirstLowcase<F>}${Sep}${SplitCamelCase<FirstLowcase<R>, Sep>}`\n// \t: S\n//\n//\n//\n// type SplitCamelCase<S, Sep extends string = '-'> = S extends `${infer First}${infer Rest}`\n// \t? Rest extends Uncapitalize<Rest>\n// \t\t? `${Uncapitalize<First>}${SplitCamelCase<Rest, Sep>}`\n// \t\t: `${Uncapitalize<First>}${Sep}${SplitCamelCase<Rest, Sep>}`\n// \t: S\n//\n//\n//\n// prettier-ignore\ntype KebabMap = { A: \"a\", B: \"b\", C: \"c\", D: \"d\", E: \"e\", F: \"f\", G: \"g\", H: \"h\", I: \"i\", J: \"j\", K: \"k\", L: \"l\", M: \"m\", N: \"n\", O: \"o\", P: \"p\", Q: \"q\", R: \"r\", S: \"s\", T: \"t\", U: \"u\", V: \"v\", W: \"w\", X: \"x\", Y: \"y\", Z: \"z\", }\ntype SplitCamelCase<\n\tS extends string,\n\tSep extends string = '-',\n\tU extends string = '',\n> = S extends `${infer Target}${infer R}`\n\t? Target extends keyof KebabMap\n\t\t? U extends ''\n\t\t\t? SplitCamelCase<R, Sep, `${U}${KebabMap[Target]}`>\n\t\t\t: SplitCamelCase<R, Sep, `${U}${Sep}${KebabMap[Target]}`>\n\t\t: SplitCamelCase<R, Sep, `${U}${Target}`>\n\t: U\n\nexport type CamelCasedProps<T> = {\n\t[K in keyof T as JoinToCamelCase<Extract<K, string>, '-'>]: T[K]\n}\n\nexport type DashCasedProps<T> = {\n\t[K in keyof T as SplitCamelCase<Extract<K, string>, '-'>]: T[K]\n}\n\n// EXAMPLES\n// type foo0 = JoinToCamelCase<'fooBarBaz'> // Becomes \"foobabaz\"\n// type foo3 = JoinToCamelCase<'foo-bar-baz'> // Becomes \"fooBarBaz\"\n// type foo5 = JoinToCamelCase<'foo bar baz', ' '> // Becomes \"fooBarBaz\"\n// type foo6 = JoinToCamelCase<'foo_bar_baz', '_'> // Becomes \"fooBarBaz\"\n// type foo14 = JoinToCamelCase<'foo:bar:baz', ':'> // Becomes \"fooBarBaz\"\n// type foo4 = JoinToCamelCase<'foobarbaz'> // the same\n// type foo7 = SplitCamelCase<'fooBar'> // Becomes \"foo-bar\"\n// type foo12 = SplitCamelCase<'fooBar', '_'> // Becomes \"foo_bar\"\n// type foo13 = SplitCamelCase<'fooBar', ' '> // Becomes \"foo bar\"\n// type foo11 = SplitCamelCase<'foo-bar'> // the same\n// type foo8 = SplitCamelCase<'foo bar'> // the same\n// type foo9 = SplitCamelCase<'foo_bar'> // the same\n// type foo10 = SplitCamelCase<'foobar'> // the same\n// type t = Join<['foo', 'bar'], ':'> // Becomes \"foo:bar\"\n//\n// interface KebabCased {\n//     \"foo-bar\": string;\n//     foo: number;\n// }\n// type CamelCased = CamelCasedProps<KebabCased>;\n// Becomes\n// {\n//    fooBar: string;\n//    foo: number;\n// }\n","import {render} from 'solid-js/web'\nimport {defer} from './_utils.js'\n\nimport type {AttributeHandler} from './attribute'\nimport type {DashCasedProps} from './_utils'\n\n// TODO `templateMode: 'append' | 'replace'`, which allows a subclass to specify\n// if template content replaces the content of `root`, or is appended to `root`.\n\nlet ctor: typeof LumeElement\n\nconst HTMLElement =\n\tglobalThis.HTMLElement ??\n\tclass HTMLElement {\n\t\tconstructor() {\n\t\t\tthrow new Error(\n\t\t\t\t\"@lume/element needs a DOM to operate with! If this code is running during server-side rendering, it means your app is trying to instantiate elements when it shouldn't be, and should be refactored to avoid doing that when no DOM is present.\",\n\t\t\t)\n\t\t}\n\t}\n\n// TODO Make LumeElement `abstract`, which had issues with mixins last time we\n// tried, but TS has been updated for abstract mixin support.\n\nclass LumeElement extends HTMLElement {\n\t/** The default tag name of the elements this class is instantiated for. */\n\tstatic elementName: string = ''\n\n\t/**\n\t * Define this class for the given element `name`, or using its default name\n\t * (`elementName`) if no `name` given. Defaults to using the global\n\t * `customElements` registry unless another registry is provided (for\n\t * example a ShadowRoot-scoped registry).\n\t *\n\t * If a `name` is given, then the class will be extended with an empty\n\t * subclass so that a new class is used for each new name, because otherwise\n\t * a CustomElementRegistry does not allow the same exact class to be used\n\t * more than once regardless of the name.\n\t *\n\t * @returns Returns the defined element class, which is only going to be a\n\t * different subclass of the class this is called on if passing in a custom\n\t * `name`, otherwise returns the same class this is called on.\n\t */\n\tstatic defineElement(name?: string, registry: CustomElementRegistry = customElements): typeof LumeElement {\n\t\tif (!name) {\n\t\t\tname = this.elementName\n\t\t\tif (registry.get(name)) {\n\t\t\t\tconsole.warn(`defineElement(): An element class was already defined for tag name ${name}.`)\n\t\t\t\treturn this\n\t\t\t}\n\t\t\tregistry.define(name, this)\n\t\t\treturn this\n\t\t} else {\n\t\t\tif (registry.get(name)) {\n\t\t\t\tconsole.warn(`defineElement(): An element class was already defined for tag name ${name}.`)\n\t\t\t\treturn this\n\t\t\t} else {\n\t\t\t\t// Allow the same element to be defined more than once using\n\t\t\t\t// alternative names.\n\t\t\t\tconst Class = class extends this {}\n\t\t\t\tClass.elementName = name\n\t\t\t\tregistry.define(name, Class)\n\t\t\t\treturn Class\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Non-decorator users can use this to specify which props are reactive. */\n\tstatic reactiveProperties?: string[]\n\n\t/** Non-decorator users can use this to specify attributes, which automatically map to reactive properties. */\n\tstatic observedAttributes?: string[] | Record<string, AttributeHandler>\n\n\t// Note, this is used in the @attribute decorator, see attribute.ts.\n\t// @ts-ignore, property is used\n\tprivate declare __attributesToProps?: Record<string, {name: string; attributeHandler?: AttributeHandler}>\n\n\tprotected declare _preUpgradeValues: Map<PropertyKey, unknown>\n\n\t// __propsSetAtLeastOnce__ comes from @lume/variable's @reactive decorator.\n\t// It is a Set<string> that tells us if a reactive property has been set at\n\t// least once,\n\tprotected declare __propsSetAtLeastOnce__?: Set<PropertyKey>\n\n\tprotected declare __reactifiedProps__?: Set<PropertyKey>\n\n\t// This property MUST be defined before any other non-static non-declared\n\t// class properties . Its initializer needs to run before any other\n\t// properties are defined, in order to detect and handle only instance\n\t// properties that already exist from custom element pre-upgrade time.\n\tprotected ___init___ = (() => {\n\t\t// XXX We could remove this and instead use a class decorator (returns a\n\t\t// new class), which would allow us to run this logic during\n\t\t// construction without requiring the user to extend from a specific\n\t\t// base class (LumeElement) unless they elect not to use decorators.\n\t\tthis.__handleInitialPropertyValuesIfAny()\n\n\t\t// XXX Should we handle initial attributes too?\n\t})()\n\n\tprivate __handleInitialPropertyValuesIfAny() {\n\t\t// We need to delete initial value-descriptor properties (if they exist)\n\t\t// and store the initial values in the storage for our reactive variable\n\t\t// accessors.\n\t\t//\n\t\t// If we don't do this, then DOM APIs like cloneNode will create our\n\t\t// node without first upgrading it, and then if someone sets a property\n\t\t// (while our reactive accessors are not yet present in the class\n\t\t// prototype) it means those values will be set as value descriptor\n\t\t// properties on the instance instead of interacting with our accessors\n\t\t// (i.e. the new properties will override our accessors that the\n\t\t// instance will gain on its prototype chain once the upgrade process\n\t\t// places our class prototype in the instance's prototype chain).\n\t\t//\n\t\t// This can also happen if we set properties on an element that isn't\n\t\t// upgraded into a custom element yet, and thus will not yet have our\n\t\t// accessors.\n\t\t//\n\t\t// Assumption: any enumerable own props must've been set on the\n\t\t// element before it was upgraded. Builtin DOM properties are\n\t\t// not enumerable.\n\n\t\tconst preUpgradeKeys = Object.keys(this) as (keyof this)[]\n\t\tthis._preUpgradeValues = new Map()\n\n\t\tfor (const propName of preUpgradeKeys) {\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(this, propName)!\n\n\t\t\t// Handle only value descriptors.\n\t\t\tif ('value' in descriptor) {\n\t\t\t\t// Delete the pre-upgrade value descriptor (1/2)...\n\t\t\t\tdelete this[propName]\n\n\t\t\t\tthis._preUpgradeValues.set(propName, descriptor.value)\n\n\t\t\t\t// NOTE, deferring allows preexisting preupgrade values\n\t\t\t\t// to be handled *after* class fields have been set\n\t\t\t\t// during Custom Element upgrade (because otherwise\n\t\t\t\t// those would override the pre-existing values we're\n\t\t\t\t// trying to assign here).\n\t\t\t\tdefer(() => {\n\t\t\t\t\tconst propSetAtLeastOnce = this.__propsSetAtLeastOnce__?.has(propName)\n\n\t\t\t\t\t// ... (2/2) and re-assign the value so that it goes through an\n\t\t\t\t\t// inherited accessor.\n\t\t\t\t\t//\n\t\t\t\t\t// If the property has been set between the time LumeElement\n\t\t\t\t\t// constructor ran and the deferred microtask, then we don't\n\t\t\t\t\t// overwrite the property's value with the pre-upgrade value\n\t\t\t\t\t// because it has been intentionally set to a desired value\n\t\t\t\t\t// already.\n\t\t\t\t\t//\n\t\t\t\t\t// AND we handle inherited props or reactified props only\n\t\t\t\t\t// (because that means there may be an accessor that needs\n\t\t\t\t\t// the value to be passed in). The @element decorator otherwise\n\t\t\t\t\t// handles non-inherited props before construction\n\t\t\t\t\t// finishes. {{\n\t\t\t\t\tif (propSetAtLeastOnce) return\n\n\t\t\t\t\tconst inheritsProperty = propName in (this as any).__proto__\n\t\t\t\t\tconst hasReactifiedProp = this.__reactifiedProps__?.has(propName)\n\n\t\t\t\t\t// TODO: Should we detect if `this[propName]` is a\n\t\t\t\t\t// non-inherited accessor (instead of hasReactifiedProp).\n\t\t\t\t\t// Maybe a base class author extending from LumeElement\n\t\t\t\t\t// needs defines a new type of accessor that needs\n\t\t\t\t\t// pre-upgrade value. Perhaps we can provide an opt-in.\n\t\t\t\t\tif (inheritsProperty || hasReactifiedProp) this[propName] = descriptor.value\n\t\t\t\t\t// }}\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// We assume a getter/setter descriptor is intentional and meant\n\t\t\t\t// to override or extend our getter/setter so we leave those\n\t\t\t\t// alone. The user is responsible for ensuring they either\n\t\t\t\t// override, or extend, our accessor with theirs.\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * If a subclass provides this, it should return DOM. It is called with\n\t * Solid.js `render()`, so it can also contain Solid.js reactivity (signals\n\t * and effects) and templating (DOM-returning reactive JSX or html template\n\t * literals).\n\t */\n\tprotected declare template?: Template\n\n\t/**\n\t * If provided, this style gets created once per ShadowRoot of each element\n\t * instantiated from this class. The expression can access `this` for string\n\t * interpolation.\n\t */\n\tprotected declare css?: string | (() => string)\n\n\t/**\n\t * If provided, this style gets created a single time for all elements\n\t * instantiated from this class, instead of once per element. If you do not\n\t * need to interpolate values into the string using `this`, then use this\n\t * static property for more performance compared to the instance property.\n\t */\n\tprotected declare static css?: string | (() => string)\n\n\t/**\n\t * When `true`, the custom element will have a `ShadowRoot`. Set to `false`\n\t * to not use a `ShadowRoot`. When `false`, styles will not be scoped via\n\t * the built-in `ShadowRoot` scoping mechanism, but by a much more simple\n\t * shared style sheet placed at the nearest root node, with `:host`\n\t * selectors converted to tag names.\n\t */\n\treadonly hasShadow: boolean = true\n\n\tprivate __root: Node | null = null\n\n\t/**\n\t * Subclasses can override this to provide an alternate Node to render into\n\t * (f.e. a subclass can `return this` to render into itself instead of making a root)\n\t */\n\tprotected get root(): Node {\n\t\tif (!this.hasShadow) return this\n\t\tif (this.__root) return this.__root\n\t\tif (this.shadowRoot) return (this.__root = this.shadowRoot)\n\t\treturn (this.__root = this.attachShadow({mode: 'open'}))\n\t}\n\tprotected set root(v: Node) {\n\t\tif (!this.hasShadow) throw new Error('Can not set root, element.hasShadow is false.')\n\t\t// @prod-prune\n\t\tif (this.__root || this.shadowRoot) throw new Error('Element root can only be set once if there is no ShadowRoot.')\n\t\tthis.__root = v\n\t}\n\n\t/**\n\t * Define which `Node` to append style sheets to when `hasShadow` is `true`.\n\t * Defaults to the `this.root`, which in turn defaults to the element's\n\t * `ShadowRoot`.  When `hasShadow` is `true`, an alternate `styleRoot` is\n\t * sometimes needed for styles to be appended elsewhere than the root. For\n\t * example, return some other `Node` within the root to append styles to.\n\t * This is ignored if `hasShadow` is `false`.\n\t */\n\tprotected get styleRoot(): Node {\n\t\treturn this.root\n\t}\n\n\tattachShadow(options: ShadowRootInit) {\n\t\tif (this.__root) console.warn('Element already has a root defined.')\n\t\treturn (this.__root = super.attachShadow(options))\n\t}\n\n\tprivate declare __dispose?: () => void\n\n\tconnectedCallback() {\n\t\tthis.__setStyle()\n\n\t\tconst template = this.template\n\n\t\t// TODO This needs testing to ensure it works with DOM or the result of JSX alike.\n\t\tif (template)\n\t\t\tthis.__dispose = render(typeof template === 'function' ? template.bind(this) : () => template, this.root)\n\t}\n\n\tdisconnectedCallback() {\n\t\tthis.__dispose && this.__dispose()\n\n\t\tthis.__cleanupStyle()\n\t}\n\n\tattributeChangedCallback?(name: string, oldVal: string | null, newVal: string | null): void\n\n\tprivate static __styleRootNodeRefCountPerTagName = new WeakMap<Node, Record<string, number>>()\n\tprivate __styleRootNode: HTMLHeadElement | ShadowRoot | null = null\n\n\t#defaultHostStyle = (hostSelector: string) => /*css*/ `${hostSelector} {\n\t\tdisplay: block;\n\t}`\n\n\tprivate __setStyle() {\n\t\tctor = this.constructor as typeof LumeElement\n\t\tconst staticCSS = typeof ctor.css === 'function' ? (ctor.css = ctor.css()) : ctor.css || ''\n\t\tconst instanceCSS = typeof this.css === 'function' ? this.css() : this.css || ''\n\n\t\tif (this.hasShadow) {\n\t\t\tconst hostSelector = ':host'\n\t\t\tconst staticStyle = document.createElement('style')\n\n\t\t\tstaticStyle.innerHTML = `\n\t\t\t\t${this.#defaultHostStyle(hostSelector)}\n\t\t\t\t${staticCSS}\n\t\t\t\t${instanceCSS}\n\t\t\t`\n\n\t\t\t// If this element has a shadow root, put the style there. This is the\n\t\t\t// standard way to scope styles to a component.\n\n\t\t\tthis.styleRoot.appendChild(staticStyle)\n\t\t} else {\n\t\t\t// When this element doesn't have a shadow root, then we want to append the\n\t\t\t// style only once to the rootNode where it lives (a ShadoowRoot or\n\t\t\t// Document). If there are multiple of this same element in the rootNode,\n\t\t\t// then the style will be added only once and will style all the elements\n\t\t\t// in the same rootNode.\n\n\t\t\t// Because we're connected, getRootNode will return either the\n\t\t\t// Document, or a ShadowRoot.\n\t\t\tconst rootNode = this.getRootNode()\n\n\t\t\tthis.__styleRootNode = rootNode === document ? document.head : (rootNode as ShadowRoot)\n\n\t\t\tlet refCountPerTagName = LumeElement.__styleRootNodeRefCountPerTagName.get(this.__styleRootNode)\n\t\t\tif (!refCountPerTagName)\n\t\t\t\tLumeElement.__styleRootNodeRefCountPerTagName.set(this.__styleRootNode, (refCountPerTagName = {}))\n\t\t\tconst refCount = refCountPerTagName[this.tagName] || 0\n\t\t\trefCountPerTagName[this.tagName] = refCount + 1\n\n\t\t\tif (refCount === 0) {\n\t\t\t\tconst hostSelector = this.tagName.toLowerCase()\n\t\t\t\tconst staticStyle = document.createElement('style')\n\n\t\t\t\tstaticStyle.innerHTML = `\n\t\t\t\t\t${this.#defaultHostStyle(hostSelector)}\n\t\t\t\t\t${staticCSS ? staticCSS.replaceAll(':host', hostSelector) : staticCSS}\n\t\t\t\t`\n\n\t\t\t\tstaticStyle.id = this.tagName.toLowerCase()\n\n\t\t\t\tthis.__styleRootNode.appendChild(staticStyle)\n\t\t\t}\n\n\t\t\tif (instanceCSS) {\n\t\t\t\t// For dynamic per-instance styles, make one style element per\n\t\t\t\t// element instance so it contains that element's unique styles,\n\t\t\t\t// associated to a unique attribute selector.\n\t\t\t\tconst id = this.tagName.toLowerCase() + '-' + this.__id\n\n\t\t\t\t// Add the unique attribute that the style selector will target.\n\t\t\t\tthis.setAttribute(id, '')\n\n\t\t\t\t// TODO Instead of creating one style element per custom\n\t\t\t\t// element, we can add the styles to a single style element. We\n\t\t\t\t// can use the CSS OM instead of innerHTML to make it faster\n\t\t\t\t// (but innerHTML is nice for dev mode because it shows the\n\t\t\t\t// content in the DOM when looking in element inspector, so\n\t\t\t\t// allow option for both).\n\t\t\t\tconst instanceStyle = (this.__dynamicStyle = document.createElement('style'))\n\n\t\t\t\tinstanceStyle.id = id\n\t\t\t\tinstanceStyle.innerHTML = instanceCSS.replaceAll(':host', `[${id}]`)\n\n\t\t\t\tconst rootNode = this.getRootNode()\n\n\t\t\t\tthis.__styleRootNode = rootNode === document ? document.head : (rootNode as ShadowRoot)\n\n\t\t\t\tthis.__styleRootNode.appendChild(instanceStyle)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static __elementId = 0\n\tprivate __id = LumeElement.__elementId++\n\tprivate __dynamicStyle: HTMLStyleElement | null = null\n\n\tprivate __cleanupStyle() {\n\t\tdo {\n\t\t\tif (this.hasShadow) break\n\n\t\t\tconst refCountPerTagName = LumeElement.__styleRootNodeRefCountPerTagName.get(this.__styleRootNode!)\n\n\t\t\tif (!refCountPerTagName) break\n\n\t\t\tlet refCount = refCountPerTagName[this.tagName]\n\n\t\t\tif (refCount === undefined) break\n\n\t\t\trefCountPerTagName[this.tagName] = --refCount\n\n\t\t\tif (refCount === 0) {\n\t\t\t\tdelete refCountPerTagName[this.tagName]\n\n\t\t\t\t// TODO PERF Improve performance by saving the style\n\t\t\t\t// instance on a static var, instead of querying for it.\n\t\t\t\tconst style = this.__styleRootNode!.querySelector('#' + this.tagName)\n\t\t\t\tstyle?.remove()\n\t\t\t}\n\t\t} while (false)\n\n\t\tif (this.__dynamicStyle) this.__dynamicStyle.remove()\n\t}\n\n\t// not used currently, but we'll leave this here so that child classes can\n\t// call super, and that way we can add an implementation later when needed.\n\tadoptedCallback() {}\n}\n\n// TODO rename the export to LumeElement in a breaking version bump.\nexport {LumeElement as Element}\n\n// This is TypeScript-specific. Eventually Hegel would like to have better\n// support for JSX. We'd need to figure how to supports types for both systems.\nimport type {JSX} from './jsx-runtime'\ntype JSXOrDOM = JSX.Element | globalThis.Element\ntype TemplateContent = JSXOrDOM | JSXOrDOM[]\ntype Template = TemplateContent | (() => TemplateContent)\n\n/**\n * A helper for defining the JSX types of an element's attributes.\n *\n * You give it your element class and a list of properties (a string\n * union type), and it outputs a type with those properties being\n * optional and dash-cased. The output object also contains all the\n * built-in HTML attributes. You can then augment the\n * JSX.IntrinsicElements definition with the attributes for your element.\n *\n * For example, you would do the following so that your element's attribute\n * are available and type checked in the JSX of any consumers:\n *\n * ```js\n * import {Element, attribute, numberAttribute, element, ElementAttributes} from '@lume/element'\n *\n * \\@element('cool-element')\n * class CoolElement extends Element {\n *   \\@attribute foo: string | null = null\n *   \\@attribute bar: string | null = 'bar'\n *   \\@numberAttribute(123) loremIpsum = 123\n * }\n *\n * declare module '@lume/element' {\n *   namespace JSX {\n *     interface IntrinsicElements {\n *       'cool-element': ElementAttributes<CoolElement, 'foo' | 'bar'>\n *     }\n *   }\n * }\n * ```\n *\n * The result is that TypeScript will properly type-check the following\n * JSX expression (notice lorem-ipsum is dash-case):\n *\n * ```jsx\n * let coolEl = <cool-element foo={'foo'} bar={null} lorem-ipsum={456}></cool-element>\n * ```\n */\nexport type ElementAttributes<\n\tElementType,\n\tSelectedProperties extends keyof ElementType,\n\tAdditionalProperties extends object = {},\n> = WithStringValues<DashCasedProps<Partial<Pick<ElementType, SelectedProperties>>>> &\n\tAdditionalProperties &\n\tOmit<JSX.HTMLAttributes<ElementType>, SelectedProperties | keyof AdditionalProperties>\n\ntype WithStringValues<Type extends object> = {\n\t[Property in keyof Type]: Type[Property] extends string ? Type[Property] : Type[Property] | string\n}\n","// TODO\n//  [x] remove the now-unnecessary modes (leave just what was 'es5' mode)\n//  [x] link helpers to each other, making it possible to destructure the arguments to definer functions\n//  [x] let access helper prototype objects extend from Object, otherwise common tools are not available.\n//  [x] accept a function as return value of function definer, to be treated as a class to derive the definition from, so that it can have access to Protected and Private helpers\n//  [x] let the returned class define protected and private getters which return the protected and private definitions.\n//  [ ] protected and private static members\n//  [ ] no `any` types\n//  [ ] other TODOs in the code\n\nimport {\n\tConstructor,\n\tcopyDescriptors,\n\tsetDefaultStaticDescriptors,\n\tsetDefaultPrototypeDescriptors,\n\thasPrototype,\n} from './utils.js'\n\nimport type {Id} from './types.js'\n\ntype ImplementationKeys = 'static' | 'private' | 'protected'\n\ntype FunctionToConstructor<T, TReturn> = T extends (...a: infer A) => void ? new (...a: A) => TReturn : never\n\n// Note, void also works the same in place of unknown\ntype ReplaceCtorReturn<T, TReturn> = T extends new (...a: infer A) => unknown ? new (...a: A) => TReturn : never\n\ntype ConstructorOrDefault<T> = T extends {constructor: infer TCtor} ? TCtor : () => void\n\n// Although the SuperType type definiton already checks that T extends from\n// Constructor, the additional check in the generic paramters is useful so\n// that we don't get an error about \"never\" which is hard to track down. The\n// generic paramter will cause a more helpful and understandable error.\n// TODO ensure that T is InstanceType of TBase\n// prettier-ignore\ntype SuperType<_T, TSuper extends Constructor<any>> = TSuper extends Constructor<infer I, infer A>\n        ? {constructor: (...a: A) => I} & InstanceType<TSuper>\n        : never\n// type SuperType<\n//     T extends InstanceType<TSuper>,\n//     TSuper extends Constructor<any>\n// > = TSuper extends Constructor<infer I, infer A>\n//     ? T extends InstanceType<TSuper>\n//         ? {constructor: (...a: A) => I} & Id<InstanceType<TSuper>>\n//         : never\n//     : never\n\ntype SuperHelper<TSuper extends Constructor> = <T>(self: T) => SuperType<T, TSuper>\ntype PrivateHelper = <T>(self: T) => T extends {__: {private: infer TPrivate}} ? TPrivate : never\ntype PublicHelper = <T>(self: T) => Omit<T, ImplementationKeys> // TODO validate instance is public?\ntype ProtectedHelper = <T>(self: T) => T extends {__: {protected: infer TProtected}} ? TProtected : never\n// type ProtectedHelper = <T>(self: T) => T extends {protected: infer TProtected} ? TProtected : never\ntype Statics<T> = T extends {static: infer TStatic} ? TStatic : {}\ntype SaveInheritedProtected<T> = T extends {protected: infer TProtected} ? TProtected : {}\n\n// there's a missing link here: if the super class of T is a native class\n// that extends from a lowclass class, then we don't inherit those protected\n// members. Any ideas?\ntype StaticsAndProtected<T> = Id<Statics<T> & {__: {protected: SaveInheritedProtected<T>}}>\n\ntype ExtractInheritedProtected<T> = T extends {__: infer TProtected} ? TProtected : {}\ntype PickImplementationKeys<T> = Pick<T, Extract<keyof T, ImplementationKeys>> // similar to Pick, but not quite\n\n// this moves the implementation keys off the constructor return type and\n// onto a fake __ property, so that we can reference the __ type within the\n// implementatin code, but so that the outside (public) doesn't see the fake\n// __ property.\ntype LowClassThis<T> = Id<Omit<T, ImplementationKeys> & {__: PickImplementationKeys<T>}>\n\ntype OmitImplementationKeys<T> = Omit<T, ImplementationKeys>\n\nimport {\n\tgetFunctionBody,\n\tsetDescriptor,\n\tpropertyIsAccessor,\n\tgetInheritedDescriptor,\n\tgetInheritedPropertyNames,\n\tWeakTwoWayMap,\n} from './utils.js'\n\nexport const staticBlacklist = ['subclass', 'extends', ...Object.getOwnPropertyNames(new Function())]\n\nconst publicProtoToProtectedProto = new WeakMap()\nconst publicProtoToPrivateProto = new WeakMap()\n\n// A two-way map to associate public instances with protected instances.\n// There is one protected instance per public instance\nconst publicToProtected = new WeakTwoWayMap()\n\n// so we can get the class scope associated with a private instance\nconst privateInstanceToClassScope = new WeakMap()\n\nconst brandToPublicPrototypes = new WeakMap()\nconst brandToProtectedPrototypes = new WeakMap()\nconst brandToPrivatePrototypes = new WeakMap()\nconst brandToPublicsPrivates = new WeakMap()\n\nconst defaultOptions = {\n\t// es5 class inheritance is simple, nice, easy, and robust\n\t// There was another mode, but it has been removed\n\tmode: 'es5',\n\n\t// false is better for performance, but true will use Function (similar to\n\t// eval) to name your class functions in the most accurate way.\n\tnativeNaming: false,\n\n\t// similar to ES6 classes:\n\tprototypeWritable: false,\n\tdefaultClassDescriptor: {\n\t\twritable: true,\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t},\n\tsetClassDescriptors: true,\n}\n\nexport class InvalidSuperAccessError extends Error {}\nexport class InvalidAccessError extends Error {}\n\nexport const Class = createClassHelper()\n\nexport function createClassHelper(options?: any) {\n\toptions = options ? {...defaultOptions, ...options} : defaultOptions\n\n\toptions.defaultClassDescriptor = {\n\t\t...defaultOptions.defaultClassDescriptor,\n\t\t...options.defaultClassDescriptor,\n\t}\n\n\tconst {mode, prototypeWritable, setClassDescriptors, nativeNaming} = options\n\n\t/*\n\t * this is just the public interface adapter for createClass(). Depending\n\t * on how you call this interface, you can do various things like:\n\t *\n\t * - anonymous empty class\n\t *\n\t *    Class()\n\t *\n\t * - named empty class\n\t *\n\t *    Class('Foo')\n\t *\n\t * - base class named Foo\n\t *\n\t *    Class('Foo', (Public, Protected, Private) => {\n\t *      someMethod() { ... },\n\t *    })\n\t *\n\t * - anonymous base class\n\t *\n\t *    Class((Public, Protected, Private) => {\n\t *      someMethod() { ... },\n\t *    })\n\t *\n\t *    Class('Foo').extends(OtherClass, (Public, Protected, Private) => ({\n\t *      someMethod() { ... },\n\t *    }))\n\t *\n\t *    OtherClass.subclass = Class\n\t *    const Bar = OtherClass.subclass((Public, Protected, Private) => {\n\t *      ...\n\t *    })\n\t *\n\t * - any class made with lowclass has a static subclass if you prefer using\n\t *   that:\n\t *\n\t *    Bar.subclass('Baz', (Public, Protected, Private) => {...})\n\t *\n\t * - but you could as well do\n\t *\n\t *    Class('Baz').extends(Bar, (Public, Protected, Private) => {...})\n\t */\n\tfunction Class(): typeof Object\n\t// export function Class<TBase>(\n\tfunction Class(name: string): {\n\t\textends<TBase extends Constructor, T>(\n\t\t\tbase: TBase,\n\t\t\tmembers: (helpers: {\n\t\t\t\tSuper: SuperHelper<TBase>\n\t\t\t\tPublic: PublicHelper\n\t\t\t\tProtected: ProtectedHelper\n\t\t\t\tPrivate: PrivateHelper\n\t\t\t}) => T &\n\t\t\t\tPartial<InstanceType<TBase>> &\n\t\t\t\tThisType<LowClassThis<T & InstanceType<TBase> & ExtractInheritedProtected<TBase>>>,\n\t\t\tbrand?: object,\n\t\t): T extends {constructor: infer _TCtor}\n\t\t\t? FunctionToConstructor<ConstructorOrDefault<T>, Id<InstanceType<TBase> & OmitImplementationKeys<T>>> &\n\t\t\t\t\tId<StaticsAndProtected<T> & Pick<TBase, keyof TBase>>\n\t\t\t: ReplaceCtorReturn<TBase, Id<InstanceType<TBase>>> & Id<StaticsAndProtected<T> & Pick<TBase, keyof TBase>>\n\t}\n\tfunction Class<T>(\n\t\tname: string,\n\t\tmembers: (\n\t\t\thelpers: {\n\t\t\t\tPublic: PublicHelper\n\t\t\t\tProtected: ProtectedHelper\n\t\t\t\tPrivate: PrivateHelper\n\t\t\t\tSuper: never\n\t\t\t}, // TODO Super is actually Object\n\t\t) => T & ThisType<LowClassThis<T>>,\n\t\tbrand?: object,\n\t): FunctionToConstructor<ConstructorOrDefault<T>, Id<OmitImplementationKeys<T>>> & Id<StaticsAndProtected<T>>\n\tfunction Class<T>(\n\t\tname: string,\n\t\tmembers: T & ThisType<LowClassThis<T>>,\n\t\tbrand?: object,\n\t): FunctionToConstructor<ConstructorOrDefault<T>, Id<OmitImplementationKeys<T>>> & Id<StaticsAndProtected<T>>\n\tfunction Class(this: any, ...args: any[]) {\n\t\tlet usingStaticSubclassMethod = false\n\n\t\t// if called as SomeConstructor.subclass, or bound to SomeConstructor\n\t\tif (typeof this === 'function') usingStaticSubclassMethod = true\n\n\t\t// f.e. `Class()`, `Class('Foo')`, `Class('Foo', {...})` , `Class('Foo',\n\t\t// {...}, Brand)`, similar to `class {}`, `class Foo {}`, class Foo\n\t\t// {...}, and class Foo {...} with branding (see comments on classBrand\n\t\t// below regarding positional privacy)\n\t\tif (args.length <= 3) {\n\t\t\tlet name = ''\n\t\t\tlet definer: any = null\n\t\t\tlet classBrand: any = null\n\n\t\t\t// f.e. `Class('Foo')`\n\t\t\tif (typeof args[0] === 'string') name = args[0]\n\t\t\t// f.e. `Class((pub, prot, priv) => ({ ... }))`\n\t\t\telse if (typeof args[0] === 'function' || typeof args[0] === 'object') {\n\t\t\t\tdefiner = args[0]\n\t\t\t\tclassBrand = args[1]\n\t\t\t}\n\n\t\t\t// f.e. `Class('Foo', (pub, prot, priv) => ({ ... }))`\n\t\t\tif (typeof args[1] === 'function' || typeof args[1] === 'object') {\n\t\t\t\tdefiner = args[1]\n\t\t\t\tclassBrand = args[2]\n\t\t\t}\n\n\t\t\t// Make a class in case we wanted to do just `Class()` or\n\t\t\t// `Class('Foo')`...\n\t\t\tconst Ctor = usingStaticSubclassMethod\n\t\t\t\t? createClass.call(this, name, definer, classBrand)\n\t\t\t\t: createClass(name, definer, classBrand)\n\n\t\t\t// ...but add the extends helper in case we wanted to do like:\n\t\t\t// Class().extends(OtherClass, (Public, Protected, Private) => ({\n\t\t\t//   ...\n\t\t\t// }))\n\t\t\tCtor.extends = function (ParentClass: any, def: any, brand: any) {\n\t\t\t\tdef = def || definer\n\t\t\t\tbrand = brand || classBrand\n\t\t\t\treturn createClass.call(ParentClass, name, def, brand)\n\t\t\t}\n\n\t\t\treturn Ctor\n\t\t}\n\n\t\tthrow new TypeError('invalid args')\n\t}\n\n\treturn Class\n\n\t/**\n\t * @param {string} className The name that the class being defined should\n\t * have.\n\t * @param {Function} definer A function or object for defining the class.\n\t * If definer a function, it is passed the Public, Protected, Private, and\n\t * Super helpers. Methods and properties can be defined on the helpers\n\t * directly.  An object containing methods and properties can also be\n\t * returned from the function. If definer is an object, the object should\n\t * be in the same format as the one returned if definer were a function.\n\t */\n\tfunction createClass(this: any, className: string, definer: (...args: any[]) => any, classBrand: object) {\n\t\t'use strict'\n\n\t\t// f.e. ParentClass.subclass((Public, Protected, Private) => {...})\n\t\tlet ParentClass = this\n\n\t\tif (typeof className !== 'string') {\n\t\t\tthrow new TypeError(`\n                You must specify a string for the 'className' argument.\n            `)\n\t\t}\n\n\t\tlet definition = null\n\n\t\t// f.e. Class('Foo', { ... })\n\t\tif (definer && typeof definer === 'object') {\n\t\t\tdefinition = definer\n\t\t}\n\n\t\t// Return early if there's no definition or parent class, just a simple\n\t\t// extension of Object. f.e. when doing just `Class()` or\n\t\t// `Class('Foo')`\n\t\telse if (!ParentClass && (!definer || (typeof definer !== 'function' && typeof definer !== 'object'))) {\n\t\t\tlet Ctor\n\n\t\t\tif (nativeNaming && className) Ctor = new Function(`return function ${className}() {}`)()\n\t\t\telse {\n\t\t\t\t// force anonymous even in ES6+\n\t\t\t\tCtor = (() => function () {})()\n\n\t\t\t\tif (className) setDescriptor(Ctor, 'name', {value: className})\n\t\t\t}\n\n\t\t\tCtor.prototype = {__proto__: Object.prototype, constructor: Ctor}\n\n\t\t\t// no static inheritance here, just like with `class Foo {}`\n\n\t\t\tsetDescriptor(Ctor, 'subclass', {\n\t\t\t\tvalue: Class,\n\t\t\t\twritable: true, // TODO maybe let's make this non writable\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t})\n\n\t\t\treturn Ctor\n\t\t}\n\n\t\t// A two-way map to associate public instances with private instances.\n\t\t// Unlike publicToProtected, this is inside here because there is one\n\t\t// private instance per class scope per instance (or to say it another\n\t\t// way, each instance has as many private instances as the number of\n\t\t// classes that the given instance has in its inheritance chain, one\n\t\t// private instance per class)\n\t\tconst scopedPublicsToPrivates = classBrand ? void undefined : new WeakTwoWayMap()\n\n\t\tif (classBrand) {\n\t\t\tif (!brandToPublicsPrivates.get(classBrand)) brandToPublicsPrivates.set(classBrand, new WeakTwoWayMap())\n\t\t}\n\n\t\t// if no brand provided, then we use the most fine-grained lexical\n\t\t// privacy. Lexical privacy is described at\n\t\t// https://github.com/tc39/proposal-class-fields/issues/60\n\t\t//\n\t\t// TODO make prototypes non-configurable so that the clasds-brand system\n\t\t// can't be tricked. For now, it's good enough, most people aren't going\n\t\t// to go out of their way to mangle with the prototypes in order to\n\t\t// force invalid private access.\n\t\tclassBrand = classBrand || {brand: 'lexical'}\n\n\t\t// the class \"scope\" that we will bind to the helper functions\n\t\tconst scope = {\n\t\t\tclassName, // convenient for debugging\n\n\t\t\tget publicToPrivate() {\n\t\t\t\treturn scopedPublicsToPrivates ? scopedPublicsToPrivates : brandToPublicsPrivates.get(classBrand)\n\t\t\t},\n\n\t\t\tclassBrand,\n\n\t\t\t// we use these to memoize the Public/Protected/Private access\n\t\t\t// helper results, to make subsequent accessses faster.\n\t\t\tcachedPublicAccesses: new WeakMap(),\n\t\t\tcachedProtectedAccesses: new WeakMap(),\n\t\t\tcachedPrivateAccesses: new WeakMap(),\n\t\t} as any\n\n\t\t// create the super helper for this class scope\n\t\tconst supers = new WeakMap()\n\t\tconst Super = superHelper.bind(null, supers, scope)\n\n\t\t// bind this class' scope to the helper functions\n\t\tconst Public = getPublicMembers.bind(null, scope) as any\n\t\tconst Protected = getProtectedMembers.bind(null, scope) as any\n\t\tconst Private = getPrivateMembers.bind(null, scope) as any\n\n\t\tPublic.prototype = {}\n\t\tProtected.prototype = {}\n\t\tPrivate.prototype = {}\n\n\t\t// alows the user to destructure arguments to definer functions\n\t\tPublic.Public = Public\n\t\tPublic.Protected = Protected\n\t\tPublic.Private = Private\n\t\tPublic.Super = Super\n\t\tProtected.Public = Public\n\t\tProtected.Protected = Protected\n\t\tProtected.Private = Private\n\t\tProtected.Super = Super\n\t\t// Private and Super are never passed as first argument\n\n\t\t// pass the helper functions to the user's class definition function\n\t\tdefinition = definition || (definer && definer(Public, Protected, Private, Super))\n\n\t\t// the user has the option of returning an object that defines which\n\t\t// properties are public/protected/private.\n\t\tif (definition && typeof definition !== 'object' && typeof definition !== 'function') {\n\t\t\tthrow new TypeError(`\n                The return value of a class definer function, if any, should be\n                an object, or a class constructor.\n            `)\n\t\t}\n\n\t\t// if a function was returned, we assume it is a class from which we\n\t\t// get the public definition from.\n\t\tlet customClass = null\n\t\tif (typeof definition === 'function') {\n\t\t\tcustomClass = definition\n\t\t\tdefinition = definition.prototype\n\t\t\tParentClass = customClass.prototype.__proto__.constructor\n\t\t}\n\n\t\tlet staticMembers\n\n\t\t// if functions were provided for the public/protected/private\n\t\t// properties of the definition object, execute them with their\n\t\t// respective access helpers, and use the objects returned from them.\n\t\tif (definition) {\n\t\t\tstaticMembers = definition.static\n\t\t\tdelete definition.static\n\n\t\t\tif (typeof definition.public === 'function') {\n\t\t\t\tdefinition.public = definition.public(Protected, Private)\n\t\t\t}\n\n\t\t\tif (typeof definition.protected === 'function') {\n\t\t\t\tdefinition.protected = definition.protected(Public, Private)\n\t\t\t}\n\n\t\t\tif (typeof definition.private === 'function') {\n\t\t\t\tdefinition.private = definition.private(Public, Protected)\n\t\t\t}\n\t\t}\n\n\t\tParentClass = ParentClass || Object\n\n\t\t// extend the parent class\n\t\tconst parentPublicPrototype = ParentClass.prototype\n\t\tconst publicPrototype = (definition && definition.public) || definition || Object.create(parentPublicPrototype)\n\t\tif (publicPrototype.__proto__ !== parentPublicPrototype) publicPrototype.__proto__ = parentPublicPrototype\n\n\t\t// extend the parent protected prototype\n\t\tconst parentProtectedPrototype = getParentProtectedPrototype(parentPublicPrototype)\n\t\tconst protectedPrototype = (definition && definition.protected) || Object.create(parentProtectedPrototype)\n\t\tif (protectedPrototype.__proto__ !== parentProtectedPrototype)\n\t\t\tprotectedPrototype.__proto__ = parentProtectedPrototype\n\t\tpublicProtoToProtectedProto.set(publicPrototype, protectedPrototype)\n\n\t\t// private prototype inherits from parent, but each private instance is\n\t\t// private only for the class of this scope\n\t\tconst parentPrivatePrototype = getParentPrivatePrototype(parentPublicPrototype)\n\t\tconst privatePrototype = (definition && definition.private) || Object.create(parentPrivatePrototype)\n\t\tif (privatePrototype.__proto__ !== parentPrivatePrototype) privatePrototype.__proto__ = parentPrivatePrototype\n\t\tpublicProtoToPrivateProto.set(publicPrototype, privatePrototype)\n\n\t\tif (!brandToPublicPrototypes.get(classBrand)) brandToPublicPrototypes.set(classBrand, new Set())\n\t\tif (!brandToProtectedPrototypes.get(classBrand)) brandToProtectedPrototypes.set(classBrand, new Set())\n\t\tif (!brandToPrivatePrototypes.get(classBrand)) brandToPrivatePrototypes.set(classBrand, new Set())\n\n\t\tbrandToPublicPrototypes.get(classBrand).add(publicPrototype)\n\t\tbrandToProtectedPrototypes.get(classBrand).add(protectedPrototype)\n\t\tbrandToPrivatePrototypes.get(classBrand).add(privatePrototype)\n\n\t\tscope.publicPrototype = publicPrototype\n\t\tscope.privatePrototype = privatePrototype\n\t\tscope.protectedPrototype = protectedPrototype\n\t\tscope.parentPublicPrototype = parentPublicPrototype\n\t\tscope.parentProtectedPrototype = parentProtectedPrototype\n\t\tscope.parentPrivatePrototype = parentPrivatePrototype\n\n\t\t// the user has the option of assigning methods and properties to the\n\t\t// helpers that we passed in, to let us know which methods and\n\t\t// properties are public/protected/private so we can assign them onto\n\t\t// the respective prototypes.\n\t\tcopyDescriptors(Public.prototype, publicPrototype)\n\t\tcopyDescriptors(Protected.prototype, protectedPrototype)\n\t\tcopyDescriptors(Private.prototype, privatePrototype)\n\n\t\tif (definition) {\n\t\t\t// delete these so we don't expose them on the class' public\n\t\t\t// prototype\n\t\t\tdelete definition.public\n\t\t\tdelete definition.protected\n\t\t\tdelete definition.private\n\n\t\t\t// if a `public` object was also supplied, we treat that as the public\n\t\t\t// prototype instead of the base definition object, so we copy the\n\t\t\t// definition's props to the `public` object\n\t\t\t//\n\t\t\t// TODO For now we copy from the definition object to the 'public'\n\t\t\t// object (publicPrototype), but this won't work with native `super`.\n\t\t\t// Maybe later, we can use a Proxy to read props from both the root\n\t\t\t// object and the public object, so that `super` works from both.\n\t\t\t// Another option is to not allow a `public` object, only protected\n\t\t\t// and private\n\t\t\tif (definition !== publicPrototype) {\n\t\t\t\t// copy whatever remains\n\t\t\t\tcopyDescriptors(definition, publicPrototype)\n\t\t\t}\n\t\t}\n\n\t\tif (customClass) {\n\t\t\tif (staticMembers) copyDescriptors(staticMembers, customClass)\n\t\t\treturn customClass\n\t\t}\n\n\t\tconst userConstructor = publicPrototype.hasOwnProperty('constructor') ? publicPrototype.constructor : null\n\n\t\tlet NewClass = null\n\t\tlet newPrototype = null\n\n\t\t// ES5 version (which seems to be so much better)\n\t\tif (mode === 'es5') {\n\t\t\tNewClass = (() =>\n\t\t\t\tfunction (this: any) {\n\t\t\t\t\tlet ret = null\n\n\t\t\t\t\tlet constructor = null\n\n\t\t\t\t\tif (userConstructor) constructor = userConstructor\n\t\t\t\t\telse constructor = ParentClass\n\n\t\t\t\t\t// Object is a special case because otherwise\n\t\t\t\t\t// `Object.apply(this)` returns a different object and we don't\n\t\t\t\t\t// want to deal with return value in that case\n\t\t\t\t\tif (constructor !== Object) ret = constructor.apply(this, arguments)\n\n\t\t\t\t\tif (ret && (typeof ret === 'object' || typeof ret === 'function')) {\n\t\t\t\t\t\t// XXX should we set ret.__proto__ = constructor.prototype\n\t\t\t\t\t\t// here? Or let the user deal with that?\n\t\t\t\t\t\treturn ret\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this\n\t\t\t\t})()\n\n\t\t\tnewPrototype = publicPrototype\n\t\t} else {\n\t\t\tthrow new TypeError(`\n                The lowclass \"mode\" option can only be 'es5' for now.\n            `)\n\t\t}\n\n\t\tif (className) {\n\t\t\tif (nativeNaming) {\n\t\t\t\tconst code = getFunctionBody(NewClass)\n\t\t\t\tconst proto = NewClass.prototype\n\n\t\t\t\tNewClass = new Function(\n\t\t\t\t\t` userConstructor, ParentClass `,\n\t\t\t\t\t`\n                    return function ${className}() { ${code} }\n                `,\n\t\t\t\t)(userConstructor, ParentClass)\n\n\t\t\t\tNewClass.prototype = proto\n\t\t\t} else {\n\t\t\t\tsetDescriptor(NewClass, 'name', {value: className})\n\t\t\t}\n\t\t}\n\n\t\tif (userConstructor && userConstructor.length) {\n\t\t\t// length is not writable, only configurable, therefore the value\n\t\t\t// has to be set with a descriptor update\n\t\t\tsetDescriptor(NewClass, 'length', {\n\t\t\t\tvalue: userConstructor.length,\n\t\t\t})\n\t\t}\n\n\t\t// static stuff {\n\n\t\t// static inheritance\n\t\tNewClass.__proto__ = ParentClass\n\n\t\tif (staticMembers) copyDescriptors(staticMembers, NewClass)\n\n\t\t// allow users to make subclasses. When subclass is called on a\n\t\t// constructor, it defines `this` which is assigned to ParentClass\n\t\t// above.\n\t\tsetDescriptor(NewClass, 'subclass', {\n\t\t\tvalue: Class,\n\t\t\twritable: true,\n\t\t\tenumerable: false,\n\t\t\tconfigurable: false,\n\t\t})\n\n\t\t// }\n\n\t\t// prototype stuff {\n\n\t\tNewClass.prototype = newPrototype\n\n\t\tNewClass.prototype.constructor = NewClass\n\n\t\t// }\n\n\t\tif (setClassDescriptors) {\n\t\t\tsetDefaultStaticDescriptors(NewClass, options, staticBlacklist)\n\t\t\tsetDescriptor(NewClass, 'prototype', {writable: prototypeWritable})\n\t\t\tsetDefaultPrototypeDescriptors(NewClass.prototype, options)\n\t\t\tsetDefaultPrototypeDescriptors(protectedPrototype, options)\n\t\t\tsetDefaultPrototypeDescriptors(privatePrototype, options)\n\t\t}\n\n\t\tscope.constructor = NewClass // convenient for debugging\n\n\t\treturn NewClass\n\t}\n}\n\n// XXX PERFORMANCE: instead of doing multiple prototype traversals with\n// hasPrototype in the following access helpers, maybe we can do a single\n// traversal and check along the way?\n//\n// Worst case examples:\n//\n//   currently:\n//     If class hierarchy has 20 classes\n//     If we detect which instance we have in order of public, protected, private\n//     If the instance we're checking is the private instance of the middle class (f.e. class 10)\n//     We'll traverse 20 public prototypes with 20 conditional checks\n//     We'll traverse 20 protected prototypes with 20 conditional checks\n//     And finally we'll traverse 10 private prototypes with 10 conditional checks\n//     TOTAL: We traverse over 50 prototypes with 50 conditional checks\n//\n//   proposed:\n//     If class hierarchy has 20 classes\n//     If we detect which instance we have in order of public, protected, private\n//     If the instance we're checking is the private instance of the middle class (f.e. class 10)\n//     We'll traverse 10 public prototypes with 3 conditional checks at each prototype\n//     TOTAL: We traverse over 10 prototypes with 30 conditional checks\n//     BUT: The conditional checking will involve reading WeakMaps instead of\n//     checking just reference equality. If we can optimize how this part\n//     works, it might be worth it.\n//\n// Can the tradeoff (less traversal and conditional checks) outweigh the\n// heavier conditional checks?\n//\n// XXX PERFORMANCE: We can also cache the access-helper results, which requires more memory,\n// but will make use of access helpers much faster, especially important for\n// animations.\n\nfunction getParentProtectedPrototype(parentPublicPrototype: any) {\n\t// look up the prototype chain until we find a parent protected prototype, if any.\n\n\tlet parentProtectedProto\n\tlet currentPublicProto = parentPublicPrototype\n\n\twhile (currentPublicProto && !parentProtectedProto) {\n\t\tparentProtectedProto = publicProtoToProtectedProto.get(currentPublicProto)\n\t\tcurrentPublicProto = currentPublicProto.__proto__\n\t}\n\n\t// TODO, now that we're finding the nearest parent protected proto,\n\t// we might not need to create an empty object for each class if we\n\t// don't find one, to avoid prototype lookup depth, as we'll connect\n\t// to the nearest one we find, if any.\n\treturn parentProtectedProto || {}\n}\n\nfunction getParentPrivatePrototype(parentPublicPrototype: any) {\n\t// look up the prototype chain until we find a parent protected prototype, if any.\n\n\tlet parentPrivateProto\n\tlet currentPublicProto = parentPublicPrototype\n\n\twhile (currentPublicProto && !parentPrivateProto) {\n\t\tparentPrivateProto = publicProtoToPrivateProto.get(currentPublicProto)\n\t\tcurrentPublicProto = currentPublicProto.__proto__\n\t}\n\n\t// TODO, now that we're finding the nearest parent protected proto,\n\t// we might not need to create an empty object for each class if we\n\t// don't find one, to avoid prototype lookup depth, as we'll connect\n\t// to the nearest one we find, if any.\n\treturn parentPrivateProto || {}\n}\n\nfunction getPublicMembers(scope: any, instance: any) {\n\tlet result = scope.cachedPublicAccesses.get(instance)\n\n\tif (result) return result\n\n\t// check only for the private instance of this class scope\n\tif (isPrivateInstance(scope, instance))\n\t\tscope.cachedPublicAccesses.set(instance, (result = getSubclassScope(instance).publicToPrivate.get(instance)))\n\t// check for an instance of the class (or its subclasses) of this scope\n\telse if (isProtectedInstance(scope, instance))\n\t\tscope.cachedPublicAccesses.set(instance, (result = publicToProtected.get(instance)))\n\t// otherwise just return whatever was passed in, it's public already!\n\telse scope.cachedPublicAccesses.set(instance, (result = instance))\n\n\treturn result\n}\n\nfunction getProtectedMembers(scope: any, instance: any) {\n\tlet result = scope.cachedProtectedAccesses.get(instance)\n\n\tif (result) return result\n\n\t// check for an instance of the class (or its subclasses) of this scope\n\t// This allows for example an instance of an Animal base class to access\n\t// protected members of an instance of a Dog child class.\n\tif (isPublicInstance(scope, instance))\n\t\tscope.cachedProtectedAccesses.set(\n\t\t\tinstance,\n\t\t\t(result = publicToProtected.get(instance) || createProtectedInstance(instance)),\n\t\t)\n\t// check for a private instance inheriting from this class scope\n\telse if (isPrivateInstance(scope, instance)) {\n\t\tconst publicInstance = getSubclassScope(instance).publicToPrivate.get(instance)\n\t\tscope.cachedProtectedAccesses.set(\n\t\t\tinstance,\n\t\t\t(result = publicToProtected.get(publicInstance) || createProtectedInstance(publicInstance)),\n\t\t)\n\t}\n\n\t// return the protected instance if it was passed in\n\telse if (isProtectedInstance(scope, instance)) scope.cachedProtectedAccesses.set(instance, (result = instance))\n\n\tif (!result) throw new InvalidAccessError('invalid access of protected member')\n\n\treturn result\n}\n\nfunction getSubclassScope(privateInstance: any) {\n\treturn privateInstanceToClassScope.get(privateInstance)\n}\n\nfunction createProtectedInstance(publicInstance: any) {\n\t// traverse instance proto chain, find first protected prototype\n\tconst protectedPrototype = findLeafmostProtectedPrototype(publicInstance)\n\n\t// make the protected instance from the found protected prototype\n\tconst protectedInstance = Object.create(protectedPrototype)\n\tpublicToProtected.set(publicInstance, protectedInstance)\n\treturn protectedInstance\n}\n\nfunction findLeafmostProtectedPrototype(publicInstance: any) {\n\tlet result = null\n\tlet currentProto = publicInstance.__proto__\n\n\twhile (currentProto) {\n\t\tresult = publicProtoToProtectedProto.get(currentProto)\n\t\tif (result) return result\n\t\tcurrentProto = currentProto.__proto__\n\t}\n\n\treturn result\n}\n\nfunction getPrivateMembers(scope: any, instance: any) {\n\tlet result = scope.cachedPrivateAccesses.get(instance)\n\n\tif (result) return result\n\n\t// check for a public instance that is or inherits from this class\n\tif (isPublicInstance(scope, instance))\n\t\tscope.cachedPrivateAccesses.set(\n\t\t\tinstance,\n\t\t\t(result = scope.publicToPrivate.get(instance) || createPrivateInstance(scope, instance)),\n\t\t)\n\t// check for a protected instance that is or inherits from this class'\n\t// protectedPrototype\n\telse if (isProtectedInstance(scope, instance)) {\n\t\tconst publicInstance = publicToProtected.get(instance)\n\t\tscope.cachedPrivateAccesses.set(\n\t\t\tinstance,\n\t\t\t(result = scope.publicToPrivate.get(publicInstance) || createPrivateInstance(scope, publicInstance)),\n\t\t)\n\t}\n\n\t// return the private instance if it was passed in\n\telse if (isPrivateInstance(scope, instance)) scope.cachedPrivateAccesses.set(instance, (result = instance))\n\n\tif (!result) throw new InvalidAccessError('invalid access of private member')\n\n\treturn result\n}\n\nfunction createPrivateInstance(scope: any, publicInstance: any) {\n\tconst privateInstance = Object.create(scope.privatePrototype)\n\tscope.publicToPrivate.set(publicInstance, privateInstance)\n\tprivateInstanceToClassScope.set(privateInstance, scope) // TODO use WeakTwoWayMap\n\treturn privateInstance\n}\n\nfunction isPublicInstance(scope: any, instance: any, brandedCheck = true) {\n\tif (!brandedCheck) return hasPrototype(instance, scope.publicPrototype)\n\n\tfor (const proto of Array.from(brandToPublicPrototypes.get(scope.classBrand))) {\n\t\tif (hasPrototype(instance, proto)) return true\n\t}\n\n\treturn false\n}\n\nfunction isProtectedInstance(scope: any, instance: any, brandedCheck = true) {\n\tif (!brandedCheck) return hasPrototype(instance, scope.protectedPrototype)\n\n\tfor (const proto of Array.from(brandToProtectedPrototypes.get(scope.classBrand))) {\n\t\tif (hasPrototype(instance, proto)) return true\n\t}\n\n\treturn false\n}\n\nfunction isPrivateInstance(scope: any, instance: any, brandedCheck = true) {\n\tif (!brandedCheck) return hasPrototype(instance, scope.privatePrototype)\n\n\tfor (const proto of Array.from(brandToPrivatePrototypes.get(scope.classBrand))) {\n\t\tif (hasPrototype(instance, proto)) return true\n\t}\n\n\treturn false\n}\n\nfunction superHelper(supers: any, scope: any, instance: any) {\n\tconst {parentPublicPrototype, parentProtectedPrototype, parentPrivatePrototype} = scope\n\n\tif (isPublicInstance(scope, instance, false)) return getSuperHelperObject(instance, parentPublicPrototype, supers)\n\n\tif (isProtectedInstance(scope, instance, false))\n\t\treturn getSuperHelperObject(instance, parentProtectedPrototype, supers)\n\n\tif (isPrivateInstance(scope, instance, false)) return getSuperHelperObject(instance, parentPrivatePrototype, supers)\n\n\tthrow new InvalidSuperAccessError('invalid super access')\n}\n\nfunction getSuperHelperObject(instance: any, parentPrototype: any, supers: any) {\n\tlet _super = supers.get(instance)\n\n\t// XXX PERFORMANCE: there's probably some ways to improve speed here using caching\n\tif (!_super) {\n\t\tsupers.set(instance, (_super = Object.create(parentPrototype)))\n\n\t\tconst keys = getInheritedPropertyNames(parentPrototype)\n\t\tlet i = keys.length\n\n\t\twhile (i--) {\n\t\t\tconst key = keys[i]\n\n\t\t\tsetDescriptor(\n\t\t\t\t_super,\n\t\t\t\tkey,\n\t\t\t\t{\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\tlet value: any = void undefined\n\n\t\t\t\t\t\tconst descriptor = getInheritedDescriptor(parentPrototype, key)\n\n\t\t\t\t\t\tif (descriptor && propertyIsAccessor(descriptor)) {\n\t\t\t\t\t\t\tconst getter = descriptor.get\n\t\t\t\t\t\t\tif (getter) value = getter.call(instance)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = parentPrototype[key]\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (value && value.call && typeof value === 'function') {\n\t\t\t\t\t\t\tvalue = value.bind(instance)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn value\n\t\t\t\t\t},\n\n\t\t\t\t\t// like native `super`, setting a super property does nothing.\n\t\t\t\t\tset: function (value) {\n\t\t\t\t\t\tconst descriptor = getInheritedDescriptor(parentPrototype, key)\n\n\t\t\t\t\t\tif (descriptor && propertyIsAccessor(descriptor)) {\n\t\t\t\t\t\t\tconst setter = descriptor.set\n\t\t\t\t\t\t\tif (setter) value = setter.call(instance, value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// just like native `super`\n\t\t\t\t\t\t\tinstance[key] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttrue,\n\t\t\t)\n\t\t}\n\t}\n\n\treturn _super\n}\n\nexport default Class\n","import type {Constructor} from './utils.js'\n\n// --- TODO handle static inheritance. Nothing has been implemented with regards to\n// static inheritance yet.\n\n// --- TODO allow the subclass (f.e. the `Foo` in `class Foo extends multiple(One,\n// Two, Three) {}`) to call each super constructor (One, Two, and Three)\n// individually with specific arguments.\n\n// --- TODO Prevent duplicate classes in the \"prototype tree\". F.e. if someone calls\n// `multiple(One, Two, Three)`, and `Three` already includes `Two`, we can\n// discard the `Two` argument and perform the combination as if `multiple(One,\n// Three)` had been called.\n\n// --- TODO cache the results, so more than one call to `multiple(One, Two, Three)`\n// returns the same class reference as the first call.\n\n// --- TODO, allow the user to handle the diamond problem in some way other than\n// (\"property or method from the first class in the list wins\"). Perhaps require\n// the user to specify which method to call. For now, it simply calls the first\n// method in the order in which the classes were passed into multiple(). Look\n// here for ideas based on how different languages handle it:\n// https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\n\nenum ImplementationMethod {\n\tPROXIES_ON_INSTANCE_AND_PROTOTYPE = 'PROXIES_ON_INSTANCE_AND_PROTOTYPE',\n\tPROXIES_ON_PROTOTYPE = 'PROXIES_ON_PROTOTYPE',\n\n\t// TODO, This will be similar to PROXIES_ON_INSTANCE_AND_PROTOTYPE, but\n\t// instead of placing a proxy on the instance, place a Proxy as a direct\n\t// prototype of the instance. I think this should work with Custom Elements,\n\t// and unlike PROXIES_ON_PROTOTYPE, super calls won't access own properties\n\t// on the instance, but actually on the prototypes (test5 super access tests\n\t// fail with PROXIES_ON_PROTOTYPE method).\n\tPROXY_AFTER_INSTANCE_AND_PROTOTYPE = 'PROXY_AFTER_INSTANCE_AND_PROTOTYPE',\n}\n\ntype MultipleOptions = {\n\tmethod: ImplementationMethod\n}\n\nexport function makeMultipleHelper(options?: MultipleOptions) {\n\t/**\n\t * Mixes the given classes into a single class. This is useful for multiple\n\t * inheritance.\n\t *\n\t * @example\n\t * class Foo {}\n\t * class Bar {}\n\t * class Baz {}\n\t * class MyClass extends multiple(Foo, Bar, Baz) {}\n\t */\n\t//  ------------ method 1, define the `multiple()` signature with overrides. The\n\t//  upside is it is easy to understand, but the downside is that name collisions\n\t//  in properties cause the collided property type to be `never`. This would make\n\t//  it more difficult to provide solution for the diamond problem.\n\t//  ----------------\n\t// function multiple(): typeof Object\n\t// function multiple<T extends Constructor>(classes: T): T\n\t// function multiple<T extends Constructor[]>(...classes: T): Constructor<ConstructorUnionToInstanceTypeUnion<T[number]>>\n\t// function multiple(...classes: any): any {\n\t//\n\t//  ------------ method 2, define the signature of `multiple()` with a single\n\t//  signature. The upside is this picks the type of the first property\n\t//  encountered when property names collide amongst all the classes passed into\n\t//  `multiple()`, but the downside is the inner implementation may require\n\t//  casting, and this approach can also cause an infinite type recursion\n\t//  depending on the types used inside the implementation.\n\t//  ----------------\n\treturn function multiple<T extends Constructor[]>(...classes: T): CombinedClasses<T> {\n\t\tconst mode = (options && options.method) || ImplementationMethod.PROXIES_ON_INSTANCE_AND_PROTOTYPE\n\n\t\tswitch (mode) {\n\t\t\tcase ImplementationMethod.PROXIES_ON_INSTANCE_AND_PROTOTYPE: {\n\t\t\t\treturn (withProxiesOnThisAndPrototype as any)(...classes)\n\t\t\t}\n\t\t\tcase ImplementationMethod.PROXIES_ON_PROTOTYPE: {\n\t\t\t\treturn (withProxiesOnPrototype as any)(...classes)\n\t\t\t}\n\t\t\tcase ImplementationMethod.PROXY_AFTER_INSTANCE_AND_PROTOTYPE: {\n\t\t\t\tthrow new Error(' not implemented yet')\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Mixes the given classes into a single class. This is useful for multiple\n * inheritance.\n *\n * @example\n * class Foo {}\n * class Bar {}\n * class Baz {}\n * class MyClass extends multiple(Foo, Bar, Baz) {}\n */\nexport const multiple = makeMultipleHelper({method: ImplementationMethod.PROXIES_ON_INSTANCE_AND_PROTOTYPE})\n// export const multiple = makeMultipleHelper({method: ImplementationMethod.PROXIES_ON_PROTOTYPE})\n\nfunction withProxiesOnThisAndPrototype<T extends Constructor[]>(...classes: T): CombinedClasses<T> {\n\t// avoid performance costs in special cases\n\tif (classes.length === 0) return Object as any\n\tif (classes.length === 1) return classes[0] as any\n\n\tconst FirstClass = classes.shift()!\n\n\t// inherit the first class normally. This allows for required native\n\t// inheritance in certain special cases (like inheriting from HTMLElement\n\t// when making Custom Elements).\n\tclass MultiClass extends FirstClass {\n\t\tconstructor(...args: any[]) {\n\t\t\tsuper(...args)\n\n\t\t\tconst instances: Object[] = []\n\n\t\t\t// make instances of the other classes to get/set properties on.\n\t\t\tlet Ctor: Constructor\n\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\tCtor = classes[i]\n\t\t\t\tconst instance = Reflect.construct(Ctor, args)\n\t\t\t\tinstances.push(instance)\n\t\t\t}\n\n\t\t\treturn new Proxy(this, {\n\t\t\t\t// No `set()` trap is needed in this Proxy handler, at least for\n\t\t\t\t// the tests so far. Methods automatically have the correct\n\t\t\t\t// receiver when the are gotten with the `get()` trap, so if any\n\t\t\t\t// methods set a property, the set happens on the expected\n\t\t\t\t// instance, just like regular [[Set]].\n\n\t\t\t\tget(target, key: string | symbol, self: MultiClass): any {\n\t\t\t\t\tif (Reflect.ownKeys(target).includes(key)) return Reflect.get(target, key, self)\n\n\t\t\t\t\tlet instance: Object\n\n\t\t\t\t\tfor (let i = 0, l = instances.length; i < l; i += 1) {\n\t\t\t\t\t\tinstance = instances[i]\n\t\t\t\t\t\tif (Reflect.ownKeys(instance).includes(key)) return Reflect.get(instance, key, self)\n\t\t\t\t\t}\n\n\t\t\t\t\tconst proto = Object.getPrototypeOf(self)\n\t\t\t\t\tif (Reflect.has(proto, key)) return Reflect.get(proto, key, self)\n\n\t\t\t\t\treturn undefined\n\t\t\t\t},\n\n\t\t\t\townKeys(target) {\n\t\t\t\t\tlet keys = Reflect.ownKeys(target)\n\n\t\t\t\t\tlet instance: Object\n\t\t\t\t\tlet instanceKeys: (string | symbol)[]\n\n\t\t\t\t\tfor (let i = 0, l = instances.length; i < l; i += 1) {\n\t\t\t\t\t\tinstance = instances[i]\n\t\t\t\t\t\tinstanceKeys = Reflect.ownKeys(instance)\n\t\t\t\t\t\tfor (let j = 0, l = instanceKeys.length; j < l; j += 1) keys.push(instanceKeys[j])\n\t\t\t\t\t}\n\n\t\t\t\t\treturn keys\n\t\t\t\t},\n\n\t\t\t\t// This makes the `in` operator work, for example.\n\t\t\t\thas(target, key: string | symbol): boolean {\n\t\t\t\t\tif (Reflect.ownKeys(target).includes(key)) return true\n\n\t\t\t\t\tlet instance: Object\n\t\t\t\t\tfor (let i = 0, l = instances.length; i < l; i += 1) {\n\t\t\t\t\t\tinstance = instances[i]\n\t\t\t\t\t\tif (Reflect.ownKeys(instance).includes(key)) return true\n\t\t\t\t\t}\n\n\t\t\t\t\t// all instances share the same prototype, so just check it once\n\t\t\t\t\tconst proto = Object.getPrototypeOf(self)\n\t\t\t\t\tif (Reflect.has(proto, key)) return true\n\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tconst newMultiClassPrototype = new Proxy(Object.create(FirstClass.prototype), {\n\t\tget(target, key: string | symbol, self: MultiClass): any {\n\t\t\tif (Reflect.has(target, key)) return Reflect.get(target, key, self)\n\n\t\t\tlet Class: Constructor\n\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\tClass = classes[i]\n\t\t\t\tif (Reflect.has(Class.prototype, key)) return Reflect.get(Class.prototype, key, self)\n\t\t\t}\n\t\t},\n\n\t\thas(target, key): boolean {\n\t\t\tif (Reflect.has(target, key)) return true\n\n\t\t\tlet Class: Constructor\n\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\tClass = classes[i]\n\t\t\t\tif (Reflect.has(Class.prototype, key)) return true\n\t\t\t}\n\n\t\t\treturn false\n\t\t},\n\t})\n\n\t// This is so that `super` calls will work. We can't replace\n\t// MultiClass.prototype with a Proxy because MultiClass.prototype is\n\t// non-configurable, so it is impossible to wrap it with a Proxy. Instead,\n\t// we stick our own custom Proxy-wrapped prototype object between\n\t// MultiClass.prototype and FirstClass.prototype.\n\tObject.setPrototypeOf(MultiClass.prototype, newMultiClassPrototype)\n\n\treturn MultiClass as unknown as CombinedClasses<T>\n}\n\nlet currentSelf: Object[] = []\n\nconst __instances__ = new WeakMap<object, Object[]>()\nconst getInstances = (inst: object): Object[] => {\n\tlet result = __instances__.get(inst)\n\tif (!result) __instances__.set(inst, (result = []))\n\treturn result\n}\n\n// function hasKey(instance: object, key: string | number | symbol, traverse: boolean = true): boolean {\n// \tif (Reflect.ownKeys(instance).includes(key)) return true\n\n// \tif (!traverse) return false\n\n// \tconst instances = __instances__.get(instance)\n// \tif (!instances) return false\n\n// \tfor (const instance of instances) if (hasKey(instance, key, true)) return true\n\n// \treturn false\n// }\n\ntype GetResult = {has: boolean; value: any}\n\nconst getResult: GetResult = {has: false, value: undefined}\n\nfunction getFromInstance(instance: object, key: string | symbol, result: GetResult): void {\n\tresult.has = false\n\tresult.value = undefined\n\n\tif (Reflect.ownKeys(instance).includes(key)) {\n\t\tresult.has = true\n\t\tresult.value = Reflect.get(instance, key)\n\t\treturn\n\t}\n\n\tconst instances = __instances__.get(instance)\n\tif (!instances) return\n\n\tfor (const instance of instances) {\n\t\t// if (hasKey(instance, key, true)) {\n\t\t//     getFromInstance(instance, key, result)\n\t\t//     return\n\t\t// }\n\n\t\tgetFromInstance(instance, key, result)\n\t\tif (result.has) return\n\t}\n}\n\nlet shouldGetFromPrototype = false\nlet topLevelMultiClassPrototype: object | null = null\n\nfunction withProxiesOnPrototype<T extends Constructor[]>(...classes: T): CombinedClasses<T> {\n\t// avoid performance costs in special cases\n\tif (classes.length === 0) return Object as any\n\tif (classes.length === 1) return classes[0] as any\n\n\tconst FirstClass = classes.shift()!\n\n\t// inherit the first class normally. This allows for required native\n\t// inheritance in certain special cases (like inheriting from HTMLElement\n\t// when making Custom Elements).\n\tclass MultiClass extends FirstClass {\n\t\tconstructor(...args: any[]) {\n\t\t\tsuper(...args)\n\n\t\t\t// This assumes no super constructor returns a different this from\n\t\t\t// their constructor. Otherwise the getInstances call won't work as\n\t\t\t// expected.\n\t\t\tconst instances = getInstances(this)\n\n\t\t\t// make instances of the other classes to get/set properties on.\n\t\t\tfor (const Ctor of classes) {\n\t\t\t\tconst instance = Reflect.construct(Ctor, args)\n\t\t\t\tinstances.push(instance)\n\t\t\t}\n\t\t}\n\t}\n\n\tconst newMultiClassPrototype = new Proxy(Object.create(FirstClass.prototype), {\n\t\tget(target, key: string | symbol, self: MultiClass): any {\n\t\t\tif (!topLevelMultiClassPrototype) topLevelMultiClassPrototype = target\n\n\t\t\tif (!shouldGetFromPrototype) {\n\t\t\t\tgetFromInstance(self, key, getResult)\n\n\t\t\t\tif (getResult.has) {\n\t\t\t\t\ttopLevelMultiClassPrototype = null\n\t\t\t\t\treturn getResult.value\n\t\t\t\t}\n\n\t\t\t\t// only the top level MultiClass subclass prototype will check\n\t\t\t\t// instances for a property. The superclass MultiClass\n\t\t\t\t// prototypes will do a regular prototype get.\n\t\t\t\tshouldGetFromPrototype = true\n\t\t\t}\n\n\t\t\t// TODO, I think instead of passing `self` we should be passing the\n\t\t\t// instances created from the classes? We need to write more tests,\n\t\t\t// especially ones that create new properties later and not at\n\t\t\t// construction time.\n\t\t\tif (shouldGetFromPrototype) {\n\t\t\t\tlet result: any = undefined\n\n\t\t\t\tif (Reflect.has(target, key)) result = Reflect.get(target, key, self)\n\n\t\t\t\tlet Class: Constructor\n\t\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\t\tClass = classes[i]\n\t\t\t\t\tif (Reflect.has(Class.prototype, key)) result = Reflect.get(Class.prototype, key, self)\n\t\t\t\t}\n\n\t\t\t\tif (topLevelMultiClassPrototype === target) {\n\t\t\t\t\ttopLevelMultiClassPrototype = null\n\t\t\t\t\tshouldGetFromPrototype = false\n\t\t\t\t}\n\n\t\t\t\treturn result\n\t\t\t}\n\n\t\t\t// currentSelf.push(self)\n\n\t\t\t// if (Reflect.ownKeys(self).includes(key)) {\n\t\t\t// \tcurrentSelf.pop()\n\t\t\t// \treturn Reflect.get(target, key, self)\n\t\t\t// }\n\n\t\t\t// currentSelf.pop()\n\n\t\t\t// for (const instance of getInstances(self)) {\n\t\t\t// \tcurrentSelf.push(instance)\n\n\t\t\t// \tif (Reflect.ownKeys(instance).includes(key)) {\n\t\t\t// \t\tcurrentSelf.pop()\n\t\t\t// \t\treturn Reflect.get(instance, key, instance)\n\t\t\t// \t}\n\n\t\t\t// \tcurrentSelf.pop()\n\t\t\t// }\n\n\t\t\t// return undefined\n\t\t},\n\n\t\tset(target, key: string | symbol, value: any, self): boolean {\n\t\t\tcurrentSelf.push(self)\n\n\t\t\t// If the key is in the current prototype chain, continue like normal...\n\t\t\tif (Reflect.has(target, key)) {\n\t\t\t\tcurrentSelf.pop()\n\t\t\t\treturn Reflect.set(target, key, value, self)\n\t\t\t}\n\n\t\t\tcurrentSelf.pop()\n\n\t\t\t// ...Otherwise if the key isn't, set it on one of the instances of the classes.\n\t\t\tfor (const instance of getInstances(self)) {\n\t\t\t\tcurrentSelf.push(instance)\n\n\t\t\t\tif (Reflect.has(instance, key)) {\n\t\t\t\t\tcurrentSelf.pop()\n\t\t\t\t\treturn Reflect.set(instance, key, value, instance)\n\t\t\t\t\t// return Reflect.set(instance, key, value, self)\n\t\t\t\t}\n\n\t\t\t\tcurrentSelf.pop()\n\t\t\t}\n\n\t\t\t// If the key is not found, set it like normal.\n\t\t\treturn Reflect.set(target, key, value, self)\n\t\t},\n\n\t\thas(target, key): boolean {\n\t\t\t// if (currentSelf.length) {\n\t\t\t// \tlet current = currentSelf[currentSelf.length - 1]\n\n\t\t\t// \twhile (current) {\n\t\t\t// \t\tif (Reflect.ownKeys(current).includes(key)) return true\n\t\t\t// \t\tcurrent = Reflect.getPrototypeOf(current) as MultiClass\n\t\t\t// \t}\n\n\t\t\t// \tfor (const instance of getInstances(current as MultiClass))\n\t\t\t// \t\tif (Reflect.has(instance, key)) return true\n\t\t\t// } else {\n\t\t\tif (Reflect.has(target, key)) return true\n\n\t\t\tlet Class: Constructor\n\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\tClass = classes[i]\n\t\t\t\tif (Reflect.has(Class.prototype, key)) return true\n\t\t\t}\n\t\t\t// }\n\n\t\t\treturn false\n\t\t},\n\t})\n\n\t// This is so that `super` calls will work. We can't replace\n\t// MultiClass.prototype with a Proxy because MultiClass.prototype is\n\t// non-configurable, so it is impossible to wrap it with a Proxy. Instead,\n\t// we stick our own custom Proxy-wrapped prototype object between\n\t// MultiClass.prototype and FirstClass.prototype.\n\tObject.setPrototypeOf(MultiClass.prototype, newMultiClassPrototype)\n\n\treturn MultiClass as unknown as CombinedClasses<T>\n}\n\n// type ConstructorUnionToInstanceTypeUnion<U> = (U extends Constructor\n//   ? (k: InstanceType<U>) => void\n//   : never) extends (k: infer I) => void\n//     ? I\n//     : never\n\ntype Shift<T extends any[]> = ((...args: T) => any) extends (_: any, ...args: infer R) => any ? R : never\ntype MixedArray<T extends Constructor<any>[]> = _MixedArray<T, {}>\ntype _MixedArray<T extends Constructor<any>[], U> = {\n\t0: new () => U\n\t1: _MixedArray<\n\t\tShift<T>,\n\t\t{\n\t\t\t[K in keyof InstanceType<T[0]> | keyof U]: K extends keyof U ? U[K] : InstanceType<T[0]>[K]\n\t\t}\n\t>\n}[T['length'] extends 0 ? 0 : 1]\n\ntype CombinedClasses<T> = T extends [] | [undefined]\n\t? typeof Object\n\t: T extends Constructor[]\n\t? MixedArray<T>\n\t: typeof Object\n","import {getInheritedDescriptor} from 'lowclass'\nimport {createSignal, createEffect, createRoot, untrack, getListener} from 'solid-js'\n\nexport interface VariableGetter<T> {\n\t(): T\n}\n\nexport interface VariableSetter<T> {\n\t(value: T): T\n}\n\n/** Represents a reactive variable. The value is set or gotten depending on passing an arg or no arg. */\nexport interface Variable<T = any> extends Iterable<VariableGetter<T> | VariableSetter<T>> {\n\t/** Gets the variable value. */\n\t(value?: undefined): T\n\t/** Sets the variable value. */\n\t(value: T): T\n\t(value?: T): void | T\n\n\tget: VariableGetter<T>\n\tset: VariableSetter<T>\n\n\t// For array destructuring convenience\n\t[0]: VariableGetter<T>\n\t[1]: VariableSetter<T>\n\t[Symbol.iterator](): IterableIterator<VariableGetter<T> | VariableSetter<T>>\n}\n\nfunction readVariable<T>(this: Variable<T>): T {\n\treturn this()\n}\nfunction writeVariable<T>(this: Variable<T>, value: T): T {\n\treturn this(value)\n}\n\n/**\n * Create a reactive variable.\n *\n * @example\n * let count = variable(0) // count starts at 0\n * count(1) // set the value of count to 1\n * count(count() + 1) // add 1\n * let currentValue = count() // read the current value\n * console.log(currentValue) // logs \"2\" to console\n */\n// eslint-disable-next-line typescript/explicit-function-return-type\nexport function variable<T>(value: T) {\n\tconst [get, set] = createSignal<T>(value, {equals: false})\n\n\t// FIXME, read arguments.length instead of detecting undefined values, because currently undefined value trigger a read, which means decoraators built on this treat `this.foo = undefined` as a read instead of a write.\n\tconst variable = ((value?: T) => {\n\t\tif (typeof value === 'undefined') return get()\n\t\tset(() => value)\n\t\treturn value\n\t}) as Variable<T>\n\n\t// WTF TypeScript, why do I need `any` here.\n\tconst getter = readVariable.bind(variable as any) as VariableGetter<T>\n\tconst setter = writeVariable.bind(variable as any) as VariableSetter<T>\n\n\t// For object destructuring convenience.\n\tvariable.get = getter\n\tvariable.set = setter\n\n\t// For array destructuring convenience.\n\tvariable[0] = getter\n\tvariable[1] = setter\n\tvariable[Symbol.iterator] = function* () {\n\t\tyield variable[0]\n\t\tyield variable[1]\n\t}\n\n\treturn variable as [VariableGetter<T>, VariableSetter<T>] & Variable<T>\n}\n\nexport type Computation = (previousValue?: unknown) => unknown\nexport type StopFunction = () => void\n\n/**\n * Automatically run a \"computation\" when any reactive variable used inside the\n * computation has changed. The \"computation\" is a function passed into\n * autorun().\n *\n * @param {Computation} f - A \"computation\" to re-run when any of the reactive\n * variables used inside of it change.\n * @return {StopFunction} - Returns a function that can be called to explicitly\n * stop the computation from running, allowing it to be garbage collected.\n */\n// TODO Option for autorun() to batch updates into a single update in the next microtask.\n// TODO Option for autorun() to skip the first run.\n// TODO Option for autorun() to provide which properties caused the re-run.\nexport function autorun(f: Computation): StopFunction {\n\tlet stop: StopFunction\n\n\tcreateRoot(dispose => {\n\t\tstop = dispose\n\t\tcreateEffect(f)\n\t})\n\n\treturn stop!\n}\n\nexport function reactive(protoOrClassElement: any, propName?: string, _descriptor?: PropertyDescriptor): any {\n\t// If used as a newer Babel decorator\n\tconst isDecoratorV2 = arguments.length === 1 && 'kind' in protoOrClassElement\n\tif (isDecoratorV2) {\n\t\tconst classElement = protoOrClassElement\n\n\t\t// If used as a class decorator.\n\t\tif (classElement.kind === 'class') return {...classElement, finisher: reactiveClassFinisher}\n\n\t\t// If used as a property or accessor decorator (@reactive isn't intended for\n\t\t// methods).\n\t\treturn {\n\t\t\t...classElement,\n\t\t\tfinisher(Class: AnyClassWithReactiveProps) {\n\t\t\t\t_trackReactiveProperty(Class, classElement.key)\n\n\t\t\t\treturn classElement.finisher?.(Class) ?? Class\n\t\t\t},\n\t\t}\n\t}\n\n\t// Used as a v1 legacy decorator.\n\n\t// If used as a class decorator.\n\tif (arguments.length === 1 && typeof protoOrClassElement === 'function') {\n\t\tconst Class = protoOrClassElement\n\t\treturn reactiveClassFinisher(Class)\n\t}\n\n\t// If used as a property or accessor decorator (this isn't intended for\n\t// methods).\n\tconst Class = protoOrClassElement.constructor\n\t_trackReactiveProperty(Class, propName!)\n}\n\nexport function _trackReactiveProperty(Class: AnyClassWithReactiveProps, propName: string) {\n\tif (!Class.reactiveProperties || !Class.hasOwnProperty('reactiveProperties')) Class.reactiveProperties = []\n\tif (!Class.reactiveProperties.includes(propName)) Class.reactiveProperties.push(propName)\n}\n\nfunction reactiveClassFinisher(Class: AnyClassWithReactiveProps) {\n\tif (Class.hasOwnProperty('__isReactive__')) return Class\n\n\treturn class ReactiveDecoratorFinisher extends Class {\n\t\t// This is a flag that other decorators can check, f.e. lume/elements @element decorator.\n\t\tstatic __isReactive__: true = true\n\n\t\tconstructor(...args: any[]) {\n\t\t\tif (getListener()) {\n\t\t\t\treturn untrack(() => {\n\t\t\t\t\tconst self = Reflect.construct(Class, args, new.target) // super()\n\t\t\t\t\treactify(self, Class)\n\t\t\t\t\treturn self\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tsuper(...args)\n\t\t\treactify(this, Class)\n\t\t}\n\t}\n}\n\nfunction _reactive(obj: ObjWithReactifiedProps, propName: PropertyKey): void {\n\tif (typeof propName !== 'string') throw new Error('TODO: support for non-string fields with @reactive decorator')\n\n\tconst vName = 'v_' + propName\n\n\t// XXX If obj already has vName, skip making an accessor? I think perhaps\n\t// not, because a subclass might override a property so it is not reactive,\n\t// and a further subclass might want to make it reactive again in which\n\t// case returning early would cause the subclass subclass's property not to\n\t// be reactive.\n\t// if (obj[vName] !== undefined) return\n\n\tlet descriptor: PropertyDescriptor | undefined = getInheritedDescriptor(obj, propName)\n\n\tlet originalGet: (() => any) | undefined\n\tlet originalSet: ((v: any) => void) | undefined\n\tlet initialValue: unknown\n\n\t// TODO if there is an inherited accessor, we need to ensure we still call\n\t// it so that we're extending instead of overriding. Otherwise placing\n\t// @reactive on a property will break that functionality in those cases.\n\t//\n\t// Right now, originalGet will only be called if it is on the current\n\t// prototype, but we aren't checking for any accessor that may be inherited.\n\n\tif (descriptor) {\n\t\toriginalGet = descriptor.get\n\t\toriginalSet = descriptor.set\n\n\t\tif (originalGet || originalSet) {\n\t\t\t// reactivity requires both\n\t\t\tif (!originalGet || !originalSet) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The `@reactive` decorator was used on an accessor named \"' +\n\t\t\t\t\t\tpropName +\n\t\t\t\t\t\t'\" which had a getter or a setter, but not both. Reactivity on accessors works only when accessors have both get and set. In this case the decorator does not do anything.',\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdelete descriptor.get\n\t\t\tdelete descriptor.set\n\t\t} else {\n\t\t\tinitialValue = descriptor.value\n\n\t\t\t// if it isn't writable, we don't need to make a reactive variable because\n\t\t\t// the value won't change\n\t\t\tif (!descriptor.writable) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The `@reactive` decorator was used on a property named ' +\n\t\t\t\t\t\tpropName +\n\t\t\t\t\t\t' that is not writable. Reactivity is not enabled for non-writable properties.',\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdelete descriptor.value\n\t\t\tdelete descriptor.writable\n\t\t}\n\t}\n\n\tdescriptor = {\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\t...descriptor,\n\t\tget: originalGet\n\t\t\t? function (this: any): unknown {\n\t\t\t\t\t// track reactivity, but get the value from the original getter\n\n\t\t\t\t\t// XXX this causes initialValue to be held onto even if the original\n\t\t\t\t\t// prototype value has changed. In pratice the original prototype\n\t\t\t\t\t// values usually never change, and these days people don't normally\n\t\t\t\t\t// use prototype values to begin with.\n\t\t\t\t\tconst v = __getReactiveVar(this, vName, initialValue)\n\t\t\t\t\tv()\n\n\t\t\t\t\treturn originalGet!.call(this)\n\t\t\t  }\n\t\t\t: function (this: any): unknown {\n\t\t\t\t\tconst v = __getReactiveVar(this, vName, initialValue)\n\t\t\t\t\treturn v()\n\t\t\t  },\n\t\tset: originalSet\n\t\t\t? function (this: any, newValue: unknown) {\n\t\t\t\t\toriginalSet!.call(this, newValue)\n\n\t\t\t\t\tconst v = __getReactiveVar(this, vName)\n\t\t\t\t\tv(newValue)\n\n\t\t\t\t\t// __propsSetAtLeastOnce__ is a Set that tracks which reactive\n\t\t\t\t\t// properties have been set at least once. @lume/element uses this\n\t\t\t\t\t// to detect if a reactive prop has been set, and if so will not\n\t\t\t\t\t// overwrite the value with any value from custom element\n\t\t\t\t\t// pre-upgrade.\n\t\t\t\t\tif (!this.__propsSetAtLeastOnce__) this.__propsSetAtLeastOnce__ = new Set<string>()\n\t\t\t\t\tthis.__propsSetAtLeastOnce__.add(propName)\n\t\t\t  }\n\t\t\t: function (this: any, newValue: unknown) {\n\t\t\t\t\tconst v = __getReactiveVar(this, vName)\n\t\t\t\t\tv(newValue)\n\n\t\t\t\t\tif (!this.__propsSetAtLeastOnce__) this.__propsSetAtLeastOnce__ = new Set<string>()\n\t\t\t\t\tthis.__propsSetAtLeastOnce__.add(propName)\n\t\t\t  },\n\t}\n\n\tif (!obj.__reactifiedProps__) obj.__reactifiedProps__ = new Set()\n\tobj.__reactifiedProps__.add(propName)\n\n\tObject.defineProperty(obj, propName, descriptor)\n}\n\nfunction __getReactiveVar<T>(instance: Obj<Variable<T>>, vName: string, initialValue: T = undefined!): Variable<T> {\n\t// NOTE alternatively, we could use a WeakMap instead of exposing the\n\t// variable on the instance. We could also use Symbols keys for\n\t// semi-privacy.\n\tlet v: Variable<T> = instance[vName]\n\n\tif (v) return v\n\n\tinstance[vName] = v = variable<T>(initialValue)\n\n\treturn v\n}\n\ntype AnyClass = new (...args: any[]) => object\ntype AnyClassWithReactiveProps = (new (...args: any[]) => object) & {\n\treactiveProperties?: string[]\n\t__isReactive__?: true\n}\n\n// Define (or unshadow) reactive accessors on obj, which is generally `this`\n// inside of a constructor (this is what the documentation prescribes).\nexport function reactify<T>(obj: T, props: (keyof T)[]): typeof obj\nexport function reactify<C extends AnyClass>(obj: InstanceType<C>, ctor: C): typeof obj\nexport function reactify(obj: Obj, propsOrClass: PropertyKey[] | AnyClassWithReactiveProps) {\n\tif (isClass(propsOrClass)) {\n\t\tconst Class = propsOrClass\n\n\t\t// let props = classReactiveProps.get(Class)\n\t\t// if (props) unshadowReactiveAccessors(obj, props)\n\t\t// props = Class.reactiveProperties\n\n\t\tconst props = Class.reactiveProperties\n\t\tif (Array.isArray(props)) createReactiveAccessors(obj, props)\n\t} else {\n\t\tconst props = propsOrClass\n\t\tcreateReactiveAccessors(obj, props)\n\t}\n\n\treturn obj\n}\n\nfunction isClass(obj: unknown): obj is AnyClass {\n\treturn typeof obj == 'function'\n}\n\n// Defines a reactive accessor on obj.\nfunction createReactiveAccessors(obj: ObjWithReactifiedProps, props: PropertyKey[]) {\n\tfor (const prop of props) {\n\t\tif (obj.__reactifiedProps__?.has(prop)) continue\n\n\t\tconst initialValue = obj[prop]\n\t\t_reactive(obj, prop)\n\t\tobj[prop] = initialValue\n\t}\n}\n\ntype Obj<T = unknown> = Record<PropertyKey, T> & {constructor: AnyClass}\ntype ObjWithReactifiedProps<T = unknown> = Obj<T> & {__reactifiedProps__?: Set<PropertyKey>}\n\n/**\n * Allow two reactive variables to depend on each other's values, without\n * causing an infinite loop.\n */\nexport function circular<Type>(\n\tfirst: VariableGetter<Type>,\n\tsetFirst: (v: Type) => void,\n\tsecond: VariableGetter<Type>,\n\tsetSecond: (v: Type) => void,\n): StopFunction {\n\tlet initial = true\n\n\tconst stop1 = autorun(() => {\n\t\tconst v = first()\n\t\tif (initial && !(initial = false)) setSecond(v)\n\t\telse initial = true\n\t})\n\n\tconst stop2 = autorun(() => {\n\t\tconst v = second()\n\t\tif (initial && !(initial = false)) setFirst(v)\n\t\telse initial = true\n\t})\n\n\treturn function stop() {\n\t\tstop1()\n\t\tstop2()\n\t}\n}\n\nexport const version = '0.9.0'\n","import type {Element as LumeElement} from './LumeElement.js'\nimport type {Constructor} from 'lowclass'\nimport {camelCaseToDash, defineProp} from './_utils.js'\n\n/**\n * A property or accessor decorator that maps an HTML attribute with the\n * dash-case version of the property, to the property. For example, if the\n * attribute decorator is used on a property called firstName, then the\n * property will be mapped to an attribute called first-name. Any time that the\n * attribute value changes (f.e. with setAttribute), then the property will\n * have this value set onto it.\n */\nexport function attribute(prototype: any, propName: string, descriptor?: PropertyDescriptor): any\nexport function attribute(handler?: AttributeHandler): (proto: any, propName: string) => any\nexport function attribute(handlerOrProto?: any, propName?: string, descriptor?: PropertyDescriptor): any {\n\t// This is true only if we're using the decorator in a Babel-compiled app\n\t// with non-legacy decorators. TypeScript only has legacy decorators.\n\tconst isDecoratorV2 = handlerOrProto && 'kind' in handlerOrProto\n\n\tif (isDecoratorV2) {\n\t\tconst classElement = handlerOrProto\n\n\t\treturn {\n\t\t\t...classElement,\n\t\t\tfinisher(Class: Constructor) {\n\t\t\t\t_attribute(Class.prototype, classElement.key)\n\t\t\t\t// return classElement.finisher?.(Class) ?? Class\n\t\t\t\treturn (classElement.finisher && classElement.finisher(Class)) ?? Class\n\t\t\t},\n\t\t}\n\t}\n\n\tif (handlerOrProto && propName) {\n\t\t// if being used as a legacy decorator directly\n\t\tconst prototype = handlerOrProto\n\t\treturn _attribute(prototype, propName, descriptor)\n\t}\n\n\t// `attribute` is being used as a decorator factory, possibly being passed a\n\t// handler, like `@attribute({...})`\n\n\tconst handler = handlerOrProto\n\n\treturn (protoOrClassElement: any, propName?: string, descriptor?: PropertyDescriptor): any => {\n\t\t// This is true only if we're using the decorator in a Babel-compiled app\n\t\t// with non-legacy decorators. TypeScript only has legacy decorators.\n\t\tconst isDecoratorV2 = protoOrClassElement && 'kind' in protoOrClassElement\n\n\t\tif (isDecoratorV2) {\n\t\t\tconst classElement = protoOrClassElement\n\n\t\t\treturn {\n\t\t\t\t...classElement,\n\t\t\t\tfinisher(Class: Constructor) {\n\t\t\t\t\t_attribute(Class.prototype, classElement.key, undefined, handler)\n\t\t\t\t\t// return classElement.finisher?.(Class) ?? Class\n\t\t\t\t\treturn (classElement.finisher && classElement.finisher(Class)) ?? Class\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\treturn _attribute(protoOrClassElement, propName!, descriptor, handler)\n\t}\n}\n\n// TODO Do similar as with the following attributeChangedCallback prototype\n// patch, but also with (dis)connected callbacks which can call an instance's\n// template method, so users don't have to extend from the LumeElement base class.\n// Extending from the LumeElement base class will be the method that non-decorator\n// users must use.\n\nexport function _attribute(\n\tprototype: any,\n\tpropName: string,\n\tdescriptor?: PropertyDescriptor,\n\tattributeHandler?: AttributeHandler,\n): any {\n\tconst ctor = prototype.constructor as typeof LumeElement & {__proto__: any}\n\n\tif (!ctor.observedAttributes || !ctor.hasOwnProperty('observedAttributes')) {\n\t\tconst inheritedAttrs = ctor.__proto__.observedAttributes\n\n\t\t// @prod-prune\n\t\tif (inheritedAttrs && !Array.isArray(inheritedAttrs)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'observedAttributes is in the wrong format. Maybe you forgot to decorate your custom element class with the `element` decorator.',\n\t\t\t)\n\t\t}\n\n\t\tdefineProp(ctor, 'observedAttributes', [...(inheritedAttrs || [])])\n\t}\n\n\t// @prod-prune\n\tif (!Array.isArray(ctor.observedAttributes)) {\n\t\tthrow new TypeError(\n\t\t\t'observedAttributes is in the wrong format. Maybe you forgot to decorate your custom element class with the `element` decorator.',\n\t\t)\n\t}\n\n\tconst attrName = camelCaseToDash(propName)\n\n\tif (!ctor.observedAttributes!.includes(attrName)) ctor.observedAttributes!.push(attrName)\n\n\tif (!ctor.reactiveProperties || !ctor.hasOwnProperty('reactiveProperties'))\n\t\tdefineProp(ctor, 'reactiveProperties', [...(ctor.reactiveProperties || [])])\n\n\tif (!ctor.reactiveProperties!.includes(propName)) ctor.reactiveProperties!.push(propName)\n\n\tmapAttributeToProp(prototype, attrName, propName, attributeHandler)\n\n\tif (descriptor) return descriptor\n}\n\n// TODO this stores attributes as an inheritance chain on the constructor. It'd\n// be more fool-proof (not publicly exposed) to store attribute-prop mappings in\n// WeakMaps, but then we'd need to implement our own inheritance\n// (prototype-like) lookup for the attributes.\nfunction mapAttributeToProp(prototype: any, attr: string, prop: string, handler?: AttributeHandler): void {\n\tif (!prototype.__hasAttributeChangedCallback) {\n\t\tprototype.__hasAttributeChangedCallback = true\n\n\t\tconst originalAttrChanged = prototype.attributeChangedCallback\n\n\t\tprototype.attributeChangedCallback = function (attr: string, oldVal: string | null, newVal: string | null) {\n\t\t\t// If the class already has an attributeChangedCallback, let is run,\n\t\t\t// and let is call or not call super.attributeChangedCallback.\n\t\t\tif (originalAttrChanged) {\n\t\t\t\toriginalAttrChanged.call(this, attr, oldVal, newVal)\n\t\t\t}\n\t\t\t// Otherwise, let's not intentionally break inheritance and be sure\n\t\t\t// we call the super method (if it exists).\n\t\t\telse {\n\t\t\t\t// This is equivalent to `super.attributeChangedCallback?()`\n\t\t\t\tprototype.__proto__?.attributeChangedCallback?.call(this, attr, oldVal, newVal)\n\t\t\t\t// prototype.__proto__ &&\n\t\t\t\t// \tprototype.__proto__.attributeChangedCallback &&\n\t\t\t\t// \tprototype.__proto__.attributeChangedCallback.call(this, attr, oldVal, newVal)\n\t\t\t}\n\n\t\t\t// map from attribute to property\n\t\t\tconst prop = this.__attributesToProps && this.__attributesToProps[attr]\n\n\t\t\tif (prop) {\n\t\t\t\tconst handler = prop.attributeHandler\n\t\t\t\tthis[prop.name] = handler && handler.from ? handler.from(newVal) : newVal\n\t\t\t}\n\t\t}\n\t}\n\t// Extend the current prototype's __attributesToProps object from the super\n\t// prototypes __attributesToProps object.\n\tif (!prototype.hasOwnProperty('__attributesToProps')) {\n\t\t// using defineProperty so that it is non-writable, non-enumerable, non-configurable\n\t\tObject.defineProperty(prototype, '__attributesToProps', {\n\t\t\tvalue: {\n\t\t\t\t__proto__: prototype.__attributesToProps || Object.prototype,\n\t\t\t},\n\t\t})\n\t}\n\n\t// TODO throw helpful warning if overriding an already-existing attribute-prop mapping\n\tif (prototype.__attributesToProps![attr]) {\n\t\tconsole.warn(\n\t\t\t'The `@attribute` decorator is overriding an already-existing attribute-to-property mapping for the \"' +\n\t\t\t\tattr +\n\t\t\t\t'\" attribute.',\n\t\t)\n\t}\n\n\tprototype.__attributesToProps![attr] = {name: prop, attributeHandler: handler}\n}\n\n// TODO We need a way for the default value to be set from class\n// fields/properties initial values, instead of having to have them supplied to the\n// decorator. But at the moment, these attribute decorators do not create\n// accessors, so in a legacy decorator environment they have no way of seeing\n// the initial values (new decorators can supply initializers). So for legacy\n// decorators we need either a way to hook onto initial sets of @reactive\n// accessors during construction, or to define @attribute's own accessors. New\n// decorators can easily use initializers. Our test setup will ensure that the\n// decorators work in all decorator environments.\n\nexport type AttributeHandler<T = any> = {\n\t// TODO `to` handler currently does nothing. If it is present, then prop\n\t// changes should reflect back to the attribute. In most cases, this is\n\t// undesirable (for performance).\n\tto?: (propValue: T) => string | null\n\tfrom?: (AttributeValue: string | null) => T\n\tdefault?: T\n}\n\ntype AttributeType<T> = (defaultValue?: T) => AttributeHandler<T>\n\nattribute.string = ((def = '') => ({\n\tdefault: def,\n\tfrom(str) {\n\t\treturn str == null ? this.default : str\n\t},\n})) as AttributeType<string>\n\nexport function stringAttribute(defaultValue = '') {\n\treturn attribute(attribute.string(defaultValue))\n}\n\nattribute.number = ((def = 0) => ({\n\tdefault: def,\n\tfrom(str) {\n\t\treturn str == null ? this.default : +str\n\t},\n})) as AttributeType<number>\n\nexport function numberAttribute(defaultValue = 0) {\n\treturn attribute(attribute.number(defaultValue))\n}\n\nattribute.boolean = ((def = false) => ({\n\tdefault: def,\n\tfrom(str) {\n\t\treturn str == null ? this.default : str !== 'false'\n\t},\n})) as AttributeType<boolean>\n\nexport function booleanAttribute(defaultValue = false) {\n\treturn attribute(attribute.boolean(defaultValue))\n}\n","import {reactive} from './variable.js'\nimport {Element} from './LumeElement.js'\nimport {_attribute} from './attribute.js'\n\nimport type {Constructor} from 'lowclass'\nimport type {AttributeHandler} from './attribute.js'\n\ntype PossibleStatics = {\n\tobservedAttributes?: string[] | Record<string, AttributeHandler>\n\treactiveProperties?: string[]\n\telementName?: string\n}\ntype ElementCtor = Constructor<HTMLElement>\n\n/**\n * A class decorator that defines the target class as a custom element with the\n * given `tagName`. The `tagName` must contain a hyphen, as per standard Custom\n * Element rules.\n *\n * If called with a name, it defines a custom element with that name automatically:\n *\n * ```js\n * \\@element('cool-element')\n * class CoolElement extends HTMLElement {\n *   // ...\n * }\n *\n * document.body.append(document.createElement('cool-element'))\n * ```\n *\n * If called the second arg set to false, then the element definition should be manually triggered:\n *\n * ```js\n * \\@element('cool-element', false)\n * class CoolElement extends HTMLElement {\n *   // ...\n * }\n *\n * // Using the class's default name:\n * CoolElement.defineElement()\n *\n * // Or using a different name:\n * CoolElement.defineElement('awesome-element')\n *\n * document.body.append(document.createElement('cool-element'))\n * ```\n *\n * Sometimes you may not want to define a name for the element,\n * however the decorator is still needed for key functionality. In\n * this case use the decorator without a calling it first, then you can\n * manually define the element in any other way as needed later:\n *\n * ```js\n * \\@element\n * class CoolElement extends HTMLElement {\n *   // ...\n * }\n *\n * // ...Manually define it at some point after making the class...\n * CoolElement.defineElement('cool-element')\n *\n * // Or:\n * customElements.define('cool-element', CoolElement)\n *\n * // But not the following (runtime error due to no name being defined):\n * CoolElement.defineElement()\n *\n * document.body.append(document.createElement('cool-element'))\n * ```\n *\n * If you call it with an empty string, it behaves the same as the previous example:\n *\n * ```js\n * \\@element('')\n * class CoolElement extends HTMLElement {...}\n *\n * // is the same as\n *\n * \\@element\n * class CoolElement extends HTMLElement {...}\n * ```\n */\nexport function element(tagName: string, autoDefine?: boolean): <T extends ElementCtor>(Class: T) => T\nexport function element<T extends ElementCtor>(Class: T): T\nexport function element(tagNameOrClassOrClassElement: string | ElementCtor, autoDefine = true): any {\n\tlet tagName = ''\n\n\t// `@element('foo-bar') class MyEl ...` or `element('my-el')(class MyEl ...)`\n\tif (typeof tagNameOrClassOrClassElement === 'string') {\n\t\ttagName = tagNameOrClassOrClassElement\n\t\treturn elementDecorator.bind(null, tagName, autoDefine)\n\t}\n\n\t// Otherwise `@element class MyEl ...` or `element(class MyEl ...)`\n\tautoDefine = false\n\tconst classOrClassElement = tagNameOrClassOrClassElement\n\treturn elementDecorator(tagName, autoDefine, classOrClassElement)\n}\n\nfunction elementDecorator(tagName: string, autoDefine: boolean, classOrClassElement: ElementCtor | {kind: any}): any {\n\t// Newer v2 decorator (used in a Babel environment, no other tool supports them currently).\n\tif ('kind' in classOrClassElement) {\n\t\tconst classElement = classOrClassElement\n\t\treturn {...classElement, finisher: elementFinisher.bind(null, tagName, autoDefine)}\n\t}\n\n\t// Legacy v1 decorator\n\tconst Class = classOrClassElement\n\treturn elementFinisher(tagName, autoDefine, Class)\n}\n\nfunction elementFinisher<C extends ElementCtor>(tagName: string, autoDefine: boolean, Class: C & PossibleStatics): C {\n\tconst attrs = Class.observedAttributes\n\n\tif (Class.hasOwnProperty('elementName')) tagName = Class.elementName || tagName\n\telse Class.elementName = tagName\n\n\tif (Array.isArray(attrs)) {\n\t\t// Nothing to do here: either the user provided a regular\n\t\t// observedAttributes array like with plain Custom Elements, or\n\t\t// they used our decorators which happen to create the array for\n\t\t// them. Either way, the take it from here with the array.\n\t} else if (attrs && typeof attrs === 'object') {\n\t\t// When we're not using decorators, our users have the option to\n\t\t// provide an observedAttributes object (insetad of the usual\n\t\t// array) to specify attribute types. In this case, we need to\n\t\t// track the types, and convert observedAttributes to an array so\n\t\t// the browser will understand it like usual.\n\n\t\t// Delete it, so that it will be re-created as an array by the\n\t\t// following _attribute calls.\n\t\tClass.observedAttributes = undefined\n\n\t\t// This also adds the props to Class.reactiveProperties.\n\t\tfor (const prop in attrs) _attribute(Class.prototype, prop, undefined, attrs[prop])\n\t}\n\n\tClass = reactive(Class)\n\n\tclass ElementDecoratorFinisher extends Class {\n\t\tconstructor(...args: any[]) {\n\t\t\tsuper(...args)\n\t\t\thandlePreUpgradeValues(this)\n\t\t}\n\t}\n\n\t// FIXME With autoDefineElements true, this won't work,\n\tif (tagName && autoDefine) customElements.define(tagName, ElementDecoratorFinisher)\n\t// but this will. Presumably because then all elements are defined after all behaviors.\n\t// if (tagName && autoDefine) Promise.resolve().then(() => customElements.define(tagName, ElementDecoratorFinisher))\n\n\treturn ElementDecoratorFinisher\n}\n\nfunction handlePreUpgradeValues(self: HTMLElement) {\n\tif (!(self instanceof Element)) return\n\n\t// @ts-ignore, protected access is ok\n\tfor (const [key, value] of self._preUpgradeValues) {\n\t\t// If the key is missing, it has already been handled, continue.\n\t\tif (!(key in self)) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Untrack the pre-upgrade value so that a subclass\n\t\t// of this class won't re-run this same logic again.\n\t\t// TODO needs testing.\n\t\t// @ts-ignore, protected access is ok\n\t\tself._preUpgradeValues.delete(key)\n\n\t\t// Unshadow any possible inherited accessor only if\n\t\t// there is not an accessor. If there is an accessor it\n\t\t// handles inheritance its own way.\n\t\tconst desc = Object.getOwnPropertyDescriptor(self, key)\n\t\tif (desc && 'value' in desc) {\n\t\t\t// @ts-expect-error dynamic decorator stuff, has no impact on user types.\n\t\t\tdelete self[key]\n\t\t}\n\n\t\t// Set the pre-upgrade value (allowing any inherited\n\t\t// accessor to operate on it).\n\t\t// @ts-expect-error dynamic decorator stuff, has no impact on user types.\n\t\tself[key] = value\n\t}\n}\n","import {identityTemplateTag} from './_utils.js'\n\n/**\n * A no-op (identity) template tag that does nothing, useful merely for marking CSS strings for syntax\n * highlighting in various text editors. For example:\n *\n * ```js\n * const style = css`\n *   .el {\n *     background: skyblue;\n *   }\n * `\n * ```\n */\nexport const css = identityTemplateTag\n","export * from './LumeElement.js'\nexport * from './variable.js'\nexport * from './attribute.js'\nexport * from './element.js'\nexport * from './css.js'\nexport type {JSX} from './jsx-runtime.js'\n\nexport const version = '0.9.0'\n"],"names":["supportsSpread","isSyntaxSupported","supportsClass","supportsNewTarget","TRUE_CONSTRUCTOR","Symbol","setPrototype","Object","setPrototypeOf","object","newPrototype","__proto__","construct","Reflect","Function","instantiator","constructor","args","target","arguments","length","TypeError","prototype","instance","value","apply","SKIP_PROPERTIES","copyProperties","source","destination","getOwnPropertyNames","defineProperty","properties","getOwnPropertySymbols","concat","i","indexOf","getOwnPropertyDescriptor","property","newless","name","usesClassSyntax","toString","substr","requiresNew","newlessConstructor","this","returnValue","error","test","message","Error","create","Node","console","newTarget","hasNewTarget","eval","code","getFunctionBody","setDescriptor","example","useStrict","WeakTwoWayMap","m","WeakMap","set","a","b","get","item","has","fn","split","shift","pop","join","descriptorDefaults","enumerable","configurable","obj","key","newDescriptor","inherited","overrideDescriptor","getInheritedDescriptor","setDescriptors","newDescriptors","currentDescriptor","currentDescriptors","getOwnPropertyDescriptors","defineProperties","oldDescriptor","writable","propertyIsAccessor","descriptor","result","currentProto","owner","getInheritedPropertyNames","keys","Array","from","Set","hasPrototype","proto","copyDescriptors","mod","props","prop","setDefaultPrototypeDescriptors","defaultClassDescriptor","descriptors","setDefaultStaticDescriptors","Ctor","staticBlacklist","includes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","o","hasOwnProperty","call","r","toStringTag","signalOptions","equals","ERROR","runEffects","runQueue","NOTPENDING","STALE","PENDING","UNOWNED","owned","cleanups","context","transPending","setTransPending","Owner","SuspenseContext","Transition","Scheduler","ExternalSourceFactory","Listener","Pending","Updates","Effects","ExecCount","detachedOwner","listener","unowned","root","updateFn","cleanNode","runUpdates","options","assign","s","observers","observerSlots","pending","comparator","readSignal","bind","running","sources","tValue","writeSignal","c","createComputation","push","updateComputation","tState","batch","q","data","children","resolveChildren","runningTransition","state","updates","lookUpstream","sSlot","sourceSlots","node","isComp","TransitionRunning","add","disposed","pure","markDownstream","time","runComputation","queueMicrotask","nextValue","err","handleError","updatedAt","init","tOwned","track","trigger","ordinary","dispose","triggerInTransition","done","l","Promise","resolve","then","t","effects","promises","queue","res","startTransition","inTransition","x","runTop","suspense","inFallback","ancestors","top","prev","wait","tasks","delete","size","scheduleQueue","e","v","len","completeUpdates","runUserEffects","userLength","user","resume","ignore","index","obs","n","fns","lookup","f","isArray","results","createProvider","id","createComputed","render","element","disposer","document","parent","accessor","marker","initial","insertExpression","current","insert","firstChild","textContent","unwrapArray","childNodes","multi","parentNode","nodeType","createTextNode","cleanChildren","array","currentArray","normalizeIncomingArray","appendNodes","bLength","aEnd","bEnd","aStart","bStart","after","nextSibling","map","insertBefore","remove","Map","sequence","replaceChild","reconcileArrays","appendChild","normalized","unwrap","dynamic","String","replacement","inserted","el","isParent","defineProp","defaultValue","createContext","ctor","HTMLElement","globalThis","LumeElement","___init___","__handleInitialPropertyValuesIfAny","hasShadow","__root","__styleRootNode","hostSelector","__id","__elementId","__dynamicStyle","defineElement","registry","customElements","warn","Class","elementName","define","preUpgradeKeys","_preUpgradeValues","propName","func","__propsSetAtLeastOnce__","inheritsProperty","hasReactifiedProp","__reactifiedProps__","shadowRoot","attachShadow","mode","styleRoot","super","connectedCallback","__setStyle","template","__dispose","disconnectedCallback","__cleanupStyle","staticCSS","css","instanceCSS","staticStyle","createElement","innerHTML","rootNode","getRootNode","head","refCountPerTagName","__styleRootNodeRefCountPerTagName","refCount","tagName","toLowerCase","replaceAll","setAttribute","instanceStyle","style","querySelector","adoptedCallback","publicProtoToProtectedProto","publicProtoToPrivateProto","publicToProtected","privateInstanceToClassScope","brandToPublicPrototypes","brandToProtectedPrototypes","brandToPrivatePrototypes","brandToPublicsPrivates","defaultOptions","nativeNaming","prototypeWritable","setClassDescriptors","InvalidSuperAccessError","InvalidAccessError","getPublicMembers","scope","cachedPublicAccesses","isPrivateInstance","getSubclassScope","publicToPrivate","isProtectedInstance","getProtectedMembers","cachedProtectedAccesses","isPublicInstance","createProtectedInstance","publicInstance","privateInstance","protectedPrototype","findLeafmostProtectedPrototype","protectedInstance","getPrivateMembers","cachedPrivateAccesses","createPrivateInstance","privatePrototype","brandedCheck","publicPrototype","classBrand","superHelper","supers","parentPublicPrototype","parentProtectedPrototype","parentPrivatePrototype","getSuperHelperObject","parentPrototype","_super","getter","setter","ImplementationMethod","usingStaticSubclassMethod","definer","createClass","extends","ParentClass","def","brand","className","scopedPublicsToPrivates","Super","Public","Protected","Private","staticMembers","customClass","static","public","protected","private","parentProtectedProto","currentPublicProto","getParentProtectedPrototype","parentPrivateProto","getParentPrivatePrototype","userConstructor","NewClass","ret","createClassHelper","PROXIES_ON_INSTANCE_AND_PROTOTYPE","readVariable","writeVariable","variable","iterator","autorun","stop","createEffect","reactive","protoOrClassElement","_descriptor","classElement","kind","finisher","reactiveClassFinisher","_trackReactiveProperty","reactiveProperties","self","reactify","__isReactive__","_reactive","vName","originalGet","originalSet","initialValue","__getReactiveVar","newValue","propsOrClass","isClass","createReactiveAccessors","circular","first","setFirst","second","setSecond","stop1","stop2","attribute","handlerOrProto","_attribute","handler","attributeHandler","observedAttributes","inheritedAttrs","attrName","replace","attr","__hasAttributeChangedCallback","originalAttrChanged","attributeChangedCallback","oldVal","newVal","__attributesToProps","mapAttributeToProp","stringAttribute","string","numberAttribute","number","booleanAttribute","boolean","tagNameOrClassOrClassElement","autoDefine","elementDecorator","classOrClassElement","elementFinisher","attrs","ElementDecoratorFinisher","desc","handlePreUpgradeValues","default","str","stringsParts","values"],"sourceRoot":""}